---
title: Llamadas de contrato
description: Ejecutar funciones de contratos inteligentes con transacciones
---
Las llamadas de contrato te permiten ejecutar funciones que cambian el estado en contratos inteligentes. A diferencia de las llamadas de solo lectura, estas crean transacciones que deben ser firmadas y transmitidas a la red.

## Llamada básica a contrato

Ejecuta una función simple de contrato creando una transacción con los parámetros requeridos.

```typescript
import { 
  makeContractCall,
  broadcastTransaction,
  AnchorMode
} from '@stacks/transactions';

async function callContract() {
  const txOptions = {
    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    contractName: 'my-contract',
    functionName: 'transfer',
    functionArgs: [],
    senderKey: 'your-private-key',
    network: 'testnet',
    anchorMode: AnchorMode.Any,
  };
  
  const transaction = await makeContractCall(txOptions);
  const broadcastResponse = await broadcastTransaction({ transaction });
  
  console.log('Transaction ID:', broadcastResponse.txid);
}
```

El `makeContractCall` La función crea una transacción que ejecutará la función especificada cuando se confirme en la cadena.

## Pasando argumentos de función

La mayoría de las funciones de contrato requieren argumentos. Utiliza los constructores de valores de Clarity para coincidir con los tipos de parámetros esperados.

```typescript
import { 
  Cl,
  makeContractCall,
} from '@stacks/transactions';

const functionArgs = [
  Cl.principal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG'), // recipient
  Cl.uint(1000000), // amount
  Cl.buffer(Buffer.from('Transfer memo', 'utf-8')), // memo
];

const txOptions = {
  contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  contractName: 'sip-010-token',
  functionName: 'transfer',
  functionArgs,
  senderKey: 'your-private-key',
  network: "testnet",
};

const transaction = await makeContractCall(txOptions);
const result = await broadcastTransaction({ transaction });
console.log('Transaction ID:', result.txid);
```

Cada tipo de Clarity tiene una función constructora correspondiente que garantiza la codificación adecuada para la blockchain.

### Tipos de argumentos complejos

```typescript
// Tuple arguments
const userInfo = Cl.tuple({
  name: Cl.string('Alice'),
  age: Cl.uint(30),
  active: Cl.bool(true),
});

// List arguments
const addresses = Cl.list([
  Cl.principal('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),
  Cl.principal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG'),
]);

```

Los valores opcionales y de respuesta tienen constructores dedicados para una adecuada seguridad de tipos.

```typescript
// Optional values
const optionalValue = Cl.some(Cl.uint(42)); // (some 42)
const noValue = Cl.none(); // none

// Response values
const successResponse = Cl.ok(Cl.uint(100));
const errorResponse = Cl.err(Cl.uint(404));
```

## Llamada de contrato con transferencia de STX

Algunos contratos requieren que se envíen STX junto con la llamada a la función, como al acuñar NFTs o pagar por servicios.

```typescript
async function mintNFT() {
  const mintPrice = 1000000; // 1 STX
  
  const txOptions = {
    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    contractName: 'nft-collection',
    functionName: 'mint',
    functionArgs: [],
    senderKey: 'your-private-key',
    network: new StacksTestnet(),
    anchorMode: AnchorMode.Any,
    // Attach STX to the contract call
    amount: mintPrice,
  };
  
  const transaction = await makeContractCall(txOptions);
  return broadcastTransaction(transaction, network);
}
```

## Manejo de respuestas de contratos

Procesar resultados de transacciones y respuestas de contratos:

```typescript
async function executeAndMonitor() {
  // Execute contract call
  const transaction = await makeContractCall({
    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    contractName: 'my-contract',
    functionName: 'process',
    functionArgs: [uintCV(100)],
    senderKey: 'your-private-key',
    network: new StacksTestnet(),
    anchorMode: AnchorMode.Any,
  });
  
  const broadcastResponse = await broadcastTransaction(transaction, network);
  const txId = broadcastResponse.txid;
  
  // Wait for confirmation
  const txInfo = await waitForConfirmation(txId, network);
  
  // Check transaction result
  if (txInfo.tx_status === 'success') {
    console.log('Contract returned:', txInfo.tx_result);
    // Parse the result based on expected return type
  } else {
    console.error('Transaction failed:', txInfo.tx_result);
  }
}

async function waitForConfirmation(txId: string, network: StacksNetwork) {
  let attempts = 0;
  const maxAttempts = 30;
  
  while (attempts < maxAttempts) {
    const response = await fetch(
      `${network.coreApiUrl}/extended/v1/tx/${txId}`
    );
    const txInfo = await response.json();
    
    if (txInfo.tx_status === 'success' || txInfo.tx_status === 'abort_by_response') {
      return txInfo;
    }
    
    await new Promise(resolve => setTimeout(resolve, 10000));
    attempts++;
  }
  
  throw new Error('Transaction confirmation timeout');
}
```

## Interacciones de contrato de múltiples pasos

Encadena múltiples llamadas a contratos:

```typescript
async function complexWorkflow() {
  // Step 1: Approve spending
  const approveTx = await makeContractCall({
    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
    contractName: 'token',
    functionName: 'approve',
    functionArgs: [
      standardPrincipalCV('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG'),
      uintCV(1000000),
    ],
    senderKey: 'your-private-key',
    network: new StacksTestnet(),
    anchorMode: AnchorMode.Any,
  });
  
  const approveResult = await broadcastTransaction(approveTx, network);
  await waitForConfirmation(approveResult.txid, network);
  
  // Step 2: Execute swap after approval
  const swapTx = await makeContractCall({
    contractAddress: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
    contractName: 'dex',
    functionName: 'swap-tokens',
    functionArgs: [
      standardPrincipalCV('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),
      uintCV(1000000),
    ],
    senderKey: 'your-private-key',
    network: new StacksTestnet(),
    anchorMode: AnchorMode.Any,
  });
  
  return broadcastTransaction(swapTx, network);
}
```

## Lecturas adicionales

* [Despliegue de contratos](/reference/stacks.js/contract-deployment)
* [Llamadas de solo lectura](/reference/stacks.js/read-only-calls)
* [Postcondiciones](/reference/stacks.js/post-conditions)
