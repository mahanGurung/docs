---
title: Implementando post-condiciones
sidebarTitle: Implementar post-condiciones
description: Aprende cómo agregar post-condiciones para proteger tus transacciones de Stacks
---
Las post-condiciones son una poderosa característica de seguridad en Stacks que protege a los usuarios de resultados inesperados en las transacciones. Este tutorial te guiará a través de la implementación de post-condiciones en tus aplicaciones para garantizar que las transacciones se comporten exactamente como los usuarios esperan.

## Lo que aprenderás

:::objectives
* Construir post-condiciones utilizando la API auxiliar Pc
* Agregar post-condiciones a diferentes tipos de transacciones
* Configurar modos de post-condición para la seguridad de las transacciones
* Implementar post-condiciones para STX, tokens fungibles y NFTs
* Manejar tokens semi-fungibles (SFTs) con post-condiciones
:::

## Requisitos previos

:::prerequisites
* Comprensión básica de las transacciones de Stacks
* Biblioteca Stacks.js instalada (`npm install @stacks/transactions`)
* Un entorno de desarrollo configurado para Stacks
:::

## Construyendo post-condiciones

El ayudante Pc en Stacks.js proporciona una API fluida inspirada en BDD para construir post-condiciones. Comienza con `Pc.principal()` para especificar qué dirección será verificada, luego encadene métodos para definir la condición.

```ts
import { Pc } from '@stacks/transactions';

// Basic structure of a post-condition
const postCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendEq(1000)
  .ustx();
```

El ayudante de PC utiliza encadenamiento de métodos para una construcción intuitiva de condiciones. Su IDE proporcionará autocompletado para los métodos disponibles en cada paso.

## Métodos de transferencia disponibles

Las post-condiciones admiten diferentes operadores de comparación y tipos de activos. Elija el método apropiado según sus requisitos de seguridad.

### Métodos de STX y tokens fungibles

```ts
// Exact amount
Pc.principal(address).willSendEq(1000).ustx();

// Greater than or equal
Pc.principal(address).willSendGte(500).ustx();

// Less than
Pc.principal(address).willSendLt(2000).ustx();
```

Métodos de comparación disponibles:

* `.willSendEq(amount)` - Exactamente igual al monto
* `.willSendGte(amount)` - Mayor o igual que la cantidad
* `.willSendGt(amount)` - Mayor que la cantidad
* `.willSendLte(amount)` - Menor o igual a la cantidad
* `.willSendLt(amount)` - Menos que la cantidad

### Métodos de tipos de activos

```ts
// STX transfers
.ustx()

// Fungible token transfers
.ft(contractAddress, tokenName)

// NFT transfers
.nft(assetIdentifier, tokenId)
```

### Métodos específicos de NFT

```ts
// Ensure NFT is sent
Pc.principal(address).willSendAsset().nft(...);

// Ensure NFT is NOT sent
Pc.principal(address).willNotSendAsset().nft(...);
```

## Configuración del modo de post-condición

El modo de post-condición determina cómo la blockchain de Stacks maneja las transferencias de activos no cubiertas explícitamente por sus post-condiciones. Esta es una configuración de seguridad crítica.

```ts
import { PostConditionMode, makeContractCall } from '@stacks/transactions';

const tx = await makeContractCall({
  // ... other transaction properties
  postConditionMode: PostConditionMode.Deny, // Recommended default
  postConditions: [
    // your post-conditions here
  ],
});
```

Opciones de modo:

* **`PostConditionMode.Deny`** (default): La transacción falla si ocurre alguna transferencia no especificada
* **`PostConditionMode.Allow`**: La transacción permite transferencias más allá de las condiciones posteriores especificadas

## Patrones de implementación comunes

### Condiciones posteriores a la transferencia de STX

Proteja las transferencias de STX especificando cantidades exactas o rangos.

```ts
import { Pc, makeSTXTokenTransfer } from '@stacks/transactions';

// Exact amount post-condition
const exactAmountCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendEq(1000)
  .ustx();

// Use in a transaction
const tx = await makeSTXTokenTransfer({
  recipient: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
  amount: 1000,
  postConditions: [exactAmountCondition],
  postConditionMode: PostConditionMode.Deny,
  // ... other properties
});
```

### Condiciones posteriores de tokens fungibles

Asegúrese de que los tokens fungibles se transfieran según lo esperado en las llamadas de contrato.

```ts
import { Pc, makeContractCall } from '@stacks/transactions';

// Minimum amount condition
const ftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendGte(500)
  .ft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.token-ft', 'token');

// Use in a contract call
const tx = await makeContractCall({
  contractAddress: 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6',
  contractName: 'token-transfer',
  functionName: 'transfer',
  functionArgs: [
    // ... function arguments
  ],
  postConditions: [ftCondition],
  // ... other properties
});
```

### Condiciones posteriores a la transferencia de NFT

Controla los cambios de propiedad de NFT con condiciones posteriores específicas.

```ts
import { Pc, Cl } from '@stacks/transactions';

// Ensure NFT is sent
const sendNftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendAsset()
  .nft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.nft-contract::nft-name', Cl.uint(1));

// Ensure NFT is NOT sent (protection against unwanted transfers)
const keepNftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willNotSendAsset()
  .nft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.nft-contract::nft-name', Cl.uint(1));
```

Usar `willNotSendAsset()` para proteger valiosos NFTs de ser transferidos inesperadamente.

### Condiciones posteriores de token semi-fungible (SFT)

Los SFT requieren un manejo especial ya que tienen propiedades tanto fungibles como no fungibles.

```ts
import { Cl, Pc } from '@stacks/transactions';

// SFT as NFT (specific token ID)
const sftNftCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendAsset()
  .nft(
    'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.sft-contract::sft-id',
    Cl.tuple({
      'token-id': Cl.uint(1),
      owner: Cl.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
    })
  );

// SFT as FT (amount-based)
const sftFtCondition = Pc
  .principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')
  .willSendEq(500)
  .ft('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.sft-contract', 'sft-token');
```

## Múltiples post-condiciones

Las transacciones complejas a menudo requieren múltiples condiciones posteriores para proteger completamente todas las transferencias de activos.

```ts
const tx = await makeContractCall({
  // ... transaction properties
  postConditions: [
    // Sender must send exactly 1000 uSTX
    Pc.principal(senderAddress).willSendEq(1000).ustx(),

    // Contract must send at least 100 tokens to user
    Pc.principal(contractAddress).willSendGte(100)
      .ft(contractAddress + '.my-token', 'my-token'),

    // User must not lose their NFT
    Pc.principal(senderAddress).willNotSendAsset()
      .nft(nftContract + '::my-nft', Cl.uint(1)),
  ],
  postConditionMode: PostConditionMode.Deny,
});
```

:::callout
type: tip

### Pruébalo

Explora el [Plantilla de post-condiciones](https://platform.hiro.so) para ejemplos interactivos.
:::

## Próximos pasos

:::next-steps
* [Llamada de contrato](/reference/stacks.js/contract-calls): Aprende cómo llamar contratos en Stacks
* [Transmisión de transacciones](/reference/stacks.js/broadcast-transactions): Aprende cómo transmitir transacciones protegidas
:::
