---
title: '@stacks/transactions'
description: Construye, decodifica y transmite transacciones para la cadena de bloques Stacks.
---
El `@stacks/transactions` El paquete proporciona funcionalidad integral para crear, firmar y transmitir transacciones en la cadena de bloques de Stacks, incluyendo transferencias de STX, implementaciones de contratos y llamadas a contratos.

## Instalación

```package-install
@stacks/transactions
```

## Funciones de transacción

### makeSTXTokenTransfer \[#makeSTXTokenTransfer]

`makeSTXTokenTransfer` crea una transacción de transferencia de tokens STX firmada.

### Firma

```typescript
function makeSTXTokenTransfer(options: SignedTokenTransferOptions): Promise<StacksTransaction>
```

### Parámetros

| Nombre | Tipo | Obligatorio | Descripción |
|--------|------|-------------|-------------|
| `recipient` | `string` | Sí | Dirección STX del destinatario |
| `amount` | `bigint` | Sí | Cantidad a transferir en microSTX |
| `senderKey` | `string` | Sí | Clave privada del remitente |
| `network` | `StacksNetwork \| string` | Sí | Configuración de red |
| `memo` | `string` | No | Campo de memo opcional |
| `fee` | `bigint` | No | Tarifa de transacción en microSTX |
| `nonce` | `bigint` | No | Nonce de cuenta |
| `anchorMode` | `AnchorMode` | No | Modo de anclaje de bloques |

### Ejemplos

#### Transferencia básica

```typescript
import { makeSTXTokenTransfer, broadcastTransaction } from '@stacks/transactions';

const transaction = await makeSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 1000000n, // 1 STX in microSTX
  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',
  network: 'mainnet'
});

const response = await broadcastTransaction({ transaction, network: 'mainnet' });
console.log(response.txid);
```

#### Transferencia con memo

```typescript
const transaction = await makeSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 2500000n,
  memo: 'Payment for services',
  senderKey: privateKey,
  network: 'testnet'
});
```

### makeUnsignedSTXTokenTransfer \[#makeUnsignedSTXTokenTransfer]

`makeUnsignedSTXTokenTransfer` crea una transacción de transferencia de tokens STX sin firmar.

### Firma

```typescript
function makeUnsignedSTXTokenTransfer(options: UnsignedTokenTransferOptions): Promise<StacksTransaction>
```

### Parámetros

| Nombre | Tipo | Obligatorio | Descripción |
|--------|------|-------------|-------------|
| `recipient` | `string` | Sí | Dirección STX del destinatario |
| `amount` | `bigint` | Sí | Cantidad a transferir en microSTX |
| `publicKey` | `string` | Sí | Clave pública del remitente |
| `network` | `StacksNetwork \| string` | Sí | Configuración de red |
| `memo` | `string` | No | Campo de memo opcional |
| `fee` | `bigint` | No | Tarifa de transacción en microSTX |
| `nonce` | `bigint` | No | Nonce de cuenta |

### Ejemplo

```typescript
import { makeUnsignedSTXTokenTransfer } from '@stacks/transactions';

const unsignedTx = await makeUnsignedSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 1000000n,
  publicKey: publicKeyString,
  network: 'mainnet'
});
```

### makeContractDeploy \[#makeContractDeploy]

`makeContractDeploy` crea una transacción de despliegue de contrato inteligente firmada.

### Firma

```typescript
function makeContractDeploy(options: SignedContractDeployOptions): Promise<StacksTransaction>
```

### Parámetros

| Nombre | Tipo | Obligatorio | Descripción |
|--------|------|-------------|-------------|
| `contractName` | `string` | Sí | Nombre para el contrato |
| `codeBody` | `string` | Sí | Código fuente del contrato Clarity |
| `senderKey` | `string` | Sí | Clave privada del implementador |
| `network` | `StacksNetwork \| string` | Sí | Configuración de red |
| `clarityVersion` | `ClarityVersion` | No | Versión de Clarity (por defecto la más reciente) |
| `fee` | `bigint` | No | Tarifa de transacción en microSTX |
| `nonce` | `bigint` | No | Nonce de cuenta |

### Ejemplos

#### Desplegar un contrato

```typescript
import { makeContractDeploy, broadcastTransaction } from '@stacks/transactions';
import { readFileSync } from 'fs';

const codeBody = readFileSync('./contract.clar', 'utf-8');

const transaction = await makeContractDeploy({
  contractName: 'my-contract',
  codeBody,
  senderKey: privateKey,
  network: 'testnet'
});

const response = await broadcastTransaction({ transaction, network: 'testnet' });
```

#### Implementar con la versión de Clarity

```typescript
const transaction = await makeContractDeploy({
  contractName: 'clarity-v3-contract',
  codeBody: contractCode,
  clarityVersion: 3,
  senderKey: privateKey,
  network: 'mainnet'
});
```

### makeContractCall \[#makeContractCall]

`makeContractCall` crea una transacción de llamada de función de contrato firmada.

### Firma

```typescript
function makeContractCall(options: SignedContractCallOptions): Promise<StacksTransaction>
```

### Parámetros

| Nombre | Tipo | Obligatorio | Descripción |
|--------|------|-------------|-------------|
| `contractAddress` | `string` | Sí | Dirección del contrato |
| `contractName` | `string` | Sí | Nombre del contrato |
| `functionName` | `string` | Sí | Función a llamar |
| `functionArgs` | `ClarityValue[]` | Sí | Argumentos de función |
| `senderKey` | `string` | Sí | Clave privada del llamante |
| `network` | `StacksNetwork \| string` | Sí | Configuración de red |
| `postConditions` | `PostCondition[]` | No | Condiciones posteriores |
| `validateWithAbi` | `boolean \| ClarityAbi` | No | Validar argumentos contra ABI |
| `fee` | `bigint` | No | Tarifa de transacción en microSTX |
| `nonce` | `bigint` | No | Nonce de cuenta |

### Ejemplos

#### Llamada básica a contrato

```typescript
import { makeContractCall, broadcastTransaction, Cl } from '@stacks/transactions';

const transaction = await makeContractCall({
  contractAddress: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR',
  contractName: 'hello-world',
  functionName: 'say-hi',
  functionArgs: [Cl.stringUtf8('Hello!')],
  senderKey: privateKey,
  network: 'testnet'
});

const response = await broadcastTransaction({ transaction, network: 'testnet' });
```

#### Llamada con condiciones posteriores

```typescript
import { makeContractCall, Cl, Pc } from '@stacks/transactions';

const postCondition = Pc.principal('SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE')
  .willSendLte(1000000n)
  .ustx();

const transaction = await makeContractCall({
  contractAddress: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR',
  contractName: 'token-contract',
  functionName: 'transfer',
  functionArgs: [
    Cl.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159'),
    Cl.uint(100n)
  ],
  postConditions: [postCondition],
  validateWithAbi: true,
  senderKey: privateKey,
  network: 'mainnet'
});
```

### sponsorTransaction \[#sponsorTransaction]

`sponsorTransaction` agrega una firma de patrocinador a una transacción, permitiendo transacciones patrocinadas.

### Firma

```typescript
function sponsorTransaction(options: SponsorTransactionOptions): Promise<StacksTransaction>
```

### Parámetros

| Nombre | Tipo | Obligatorio | Descripción |
|--------|------|-------------|-------------|
| `transaction` | `StacksTransaction` | Sí | Transacción a patrocinar |
| `sponsorPrivateKey` | `string` | Sí | Clave privada del patrocinador |
| `fee` | `bigint` | Sí | Tarifa a ser pagada por el patrocinador |
| `sponsorNonce` | `bigint` | No | Nonce de la cuenta del patrocinador |

### Ejemplo

```typescript
import { sponsorTransaction, deserializeTransaction, broadcastTransaction } from '@stacks/transactions';

// Deserialize the transaction from the origin
const deserializedTx = deserializeTransaction(serializedTx);

// Sponsor the transaction
const sponsoredTx = await sponsorTransaction({
  transaction: deserializedTx,
  sponsorPrivateKey: sponsorKey,
  fee: 1000n,
  sponsorNonce: 0
});

const response = await broadcastTransaction({ transaction: sponsoredTx, network: 'testnet' });
```

### fetchCallReadOnlyFunction \[#fetchCallReadOnlyFunction]

`fetchCallReadOnlyFunction` llama a una función de contrato de solo lectura sin crear una transacción.

### Firma

```typescript
function fetchCallReadOnlyFunction(options: CallReadOnlyFunctionOptions): Promise<ClarityValue>
```

### Parámetros

| Nombre | Tipo | Obligatorio | Descripción |
|--------|------|-------------|-------------|
| `contractAddress` | `string` | Sí | Dirección del contrato |
| `contractName` | `string` | Sí | Nombre del contrato |
| `functionName` | `string` | Sí | Función a llamar |
| `functionArgs` | `ClarityValue[]` | Sí | Argumentos de función |
| `network` | `StacksNetwork` | Sí | Configuración de red |
| `senderAddress` | `string` | Sí | Dirección del llamante |

### Ejemplo

```typescript
import { fetchCallReadOnlyFunction, Cl } from '@stacks/transactions';
import { STACKS_MAINNET } from '@stacks/network';

const result = await fetchCallReadOnlyFunction({
  contractAddress: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR',
  contractName: 'data-store',
  functionName: 'get-value',
  functionArgs: [Cl.stringUtf8('key')],
  network: STACKS_MAINNET,
  senderAddress: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159'
});

console.log(result);
```

### broadcastTransaction \[#broadcastTransaction]

`broadcastTransaction` transmite una transacción firmada a la red.

### Firma

```typescript
function broadcastTransaction(options: BroadcastTransactionOptions): Promise<TxBroadcastResult>
```

### Parámetros

| Nombre | Tipo | Obligatorio | Descripción |
|--------|------|-------------|-------------|
| `transaction` | `StacksTransaction` | Sí | Transacción firmada para transmitir |
| `network` | `StacksNetwork \| string` | Sí | Red a la que transmitir |

### Ejemplo

```typescript
import { broadcastTransaction } from '@stacks/transactions';

const result = await broadcastTransaction({
  transaction: signedTx,
  network: 'mainnet'
});

if (result.error) {
  console.error('Broadcast failed:', result.reason);
} else {
  console.log('Transaction ID:', result.txid);
}
```

## Construcción de valor de claridad

### Valores primitivos

```typescript
import { Cl } from '@stacks/transactions';

// Boolean values
const isTrue = Cl.bool(true);
const isFalse = Cl.bool(false);

// Integer values (signed 128-bit)
const positiveInt = Cl.int(42n);
const negativeInt = Cl.int(-100n);

// Unsigned integer values (unsigned 128-bit)
const unsignedInt = Cl.uint(100n);

// Buffer values
const buffer = Cl.bufferFromUtf8('hello world');
const hexBuffer = Cl.bufferFromHex('0x1234');

// String values
const asciiStr = Cl.stringAscii('Hello ASCII');
const utf8Str = Cl.stringUtf8('Hello UTF-8! 👋');
```

### Valores complejos

```typescript
// Principal values
const standardPrincipal = Cl.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159');
const contractPrincipal = Cl.contractPrincipal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', 'my-contract');

// Optional values
const none = Cl.none();
const some = Cl.some(Cl.uint(42n));

// Response values
const okResponse = Cl.ok(Cl.stringUtf8('Success'));
const errResponse = Cl.error(Cl.uint(404n));

// Tuple values
const tuple = Cl.tuple({
  name: Cl.stringUtf8('Alice'),
  age: Cl.uint(30n),
  active: Cl.bool(true)
});

// List values
const list = Cl.list([Cl.uint(1n), Cl.uint(2n), Cl.uint(3n)]);
```

## Postcondiciones

### Condiciones posteriores de STX

```typescript
import { Pc } from '@stacks/transactions';

// Standard principal STX post condition
const stxPostCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159')
  .willSendGte(1000000n)
  .ustx();

// Contract principal STX post condition
const contractStxCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159.my-contract')
  .willSendEq(500000n)
  .ustx();
```

### Condiciones posteriores de tokens fungibles

```typescript
// Standard principal fungible token post condition
const ftPostCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159')
  .willSendLte(100n)
  .ft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.token-contract', 'my-token');

// Contract principal fungible token post condition
const contractFtCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159.vault')
  .willNotSend()
  .ft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.token-contract', 'my-token');
```

### Condiciones posteriores de tokens no fungibles

```typescript
// Standard principal NFT post condition
const nftPostCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159')
  .willSend()
  .nft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.nft-contract', 'my-nft', Cl.uint(1n));

// Contract principal NFT post condition
const contractNftCondition = Pc.principal('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159.marketplace')
  .willNotSend()
  .nft('SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.nft-contract', 'my-nft', Cl.uint(1n));
```

## Transacciones de firma múltiple

Las transacciones de firma múltiple requieren múltiples firmas antes de ser transmitidas.

```typescript
import {
  makeUnsignedSTXTokenTransfer,
  createStacksPrivateKey,
  deserializeTransaction,
  pubKeyfromPrivKey,
  publicKeyToString,
  TransactionSigner,
  BytesReader
} from '@stacks/transactions';

// Create unsigned multi-sig transaction
const transaction = await makeUnsignedSTXTokenTransfer({
  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',
  amount: 1000000n,
  fee: 200n,
  numSignatures: 2, // Require 2 of 3 signatures
  publicKeys: [publicKey1, publicKey2, publicKey3],
  network: 'mainnet'
});

// Sign with multiple parties
const deserializedTx = deserializeTransaction(transaction.serialize());
const signer = new TransactionSigner(deserializedTx);

// Add required signatures
signer.signOrigin(privateKey1);
signer.signOrigin(privateKey2);

// Append public key of non-signing party
signer.appendOrigin(publicKey3);

// Broadcast the multi-sig transaction
const signedTx = deserializedTx;
const response = await broadcastTransaction({ transaction: signedTx, network: 'mainnet' });
```

## Utilidades de generación de claves

### randomPrivateKey \[#randomPrivateKey]

`randomPrivateKey` genera una nueva clave privada aleatoria.

```typescript
import { randomPrivateKey } from '@stacks/transactions';

const privateKey = randomPrivateKey();
console.log(privateKey); // Random 32-byte hex string with optional compression flag
```

### privateKeyToPublicKey \[#privateKeyToPublicKey]

`privateKeyToPublicKey` deriva una clave pública a partir de una clave privada.

```typescript
import { privateKeyToPublicKey } from '@stacks/transactions';

const privateKey = 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01';
const publicKey = privateKeyToPublicKey(privateKey);
console.log(publicKey); // Compressed public key
```

## Funciones de utilidad

### deserializarTransacción \[#deserializeTransaction]

`deserializeTransaction` convierte una transacción serializada de vuelta a un objeto de transacción.

```typescript
import { deserializeTransaction } from '@stacks/transactions';

const serializedTx = '0x00000000...'; // Hex string
const transaction = deserializeTransaction(serializedTx);
```

### cvToJSON \[#cvToJSON]

`cvToJSON` convierte valores de Clarity a formato JSON para una manipulación más fácil.

```typescript
import { cvToJSON, hexToCV } from '@stacks/transactions';

const clarityValue = hexToCV('0x0100000000000000000000000000000001');
const json = cvToJSON(clarityValue);
console.log(json); // { type: 'uint', value: '1' }
```
