---
title: Referencia de funciones
sidebarTitle: Funciones
description: Referencia completa de todas las funciones de Clarity organizadas por categoría, desde operaciones aritméticas hasta gestión de tokens.
---
Clarity proporciona un conjunto completo de funciones incorporadas para el desarrollo de contratos inteligentes. Estas funciones abarcan desde aritmética básica hasta operaciones complejas de tokens e interacciones con la cadena de bloques.

## Operaciones aritméticas \[#arithmetic-operations]

### + (agregar) \[#add]

`+` realiza la suma de un número variable de entradas enteras.

**Firma**

```clarity
(+ i1 i2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| i1, i2, ... | `int` o `uint` | Dos o más enteros para sumar |

```clarity
(+ 1 2 3) ;; Returns 6
(+ u10 u20) ;; Returns u30

;; Counter example
(define-data-var counter int 0)
(define-public (increment (amount int))
  (begin
    (var-set counter (+ (var-get counter) amount))
    (ok (var-get counter))))
```

### - (restar) \[#subtract]

`-` realiza la resta en un número variable de entradas enteras.

**Firma**

```clarity
(- i1 i2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| i1, i2, ... | `int` o `uint` | Dos o más enteros para restar |

```clarity
(- 10 3) ;; Returns 7
(- 100 20 10) ;; Returns 70
(- u50 u30) ;; Returns u20

;; Decrease balance
(define-public (withdraw (amount uint))
  (let ((balance (var-get user-balance)))
    (asserts! (>= balance amount) (err u1))
    (var-set user-balance (- balance amount))
    (ok amount)))
```

### \* (multiplicar) \[#multiply]

`*` realiza la multiplicación de un número variable de entradas enteras.

**Firma**

```clarity
(* i1 i2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| i1, i2, ... | `int` o `uint` | Dos o más números enteros para multiplicar |

```clarity
(* 3 4) ;; Returns 12
(* 2 3 4) ;; Returns 24
(* u5 u10) ;; Returns u50

;; Calculate percentage
(define-read-only (calculate-fee (amount uint))
  (/ (* amount u3) u100)) ;; 3% fee
```

### / (dividir) \[#divide]

`/` realiza la división entera en un número variable de entradas enteras.

**Firma**

```clarity
(/ i1 i2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| i1, i2, ... | `int` o `uint` | Dos o más enteros para dividir |

```clarity
(/ 10 2) ;; Returns 5
(/ 100 10 2) ;; Returns 5
(/ u60 u3) ;; Returns u20

;; Calculate average
(define-read-only (average (a uint) (b uint))
  (/ (+ a b) u2))
```

### mod \[#mod]

`mod` devuelve el resto de la división entera.

**Firma**

```clarity
(mod i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Dividendo |
| `i2` | `int` o `uint` | Divisor |

```clarity
(mod 10 3) ;; Returns 1
(mod u17 u5) ;; Returns u2

;; Check if even
(define-read-only (is-even (n uint))
  (is-eq (mod n u2) u0))
```

### pow \[#pow]

`pow` eleva un número a una potencia.

**Firma**

```clarity
(pow i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Base |
| `i2` | `int` o `uint` | Exponente |

```clarity
(pow 2 3) ;; Returns 8
(pow u10 u2) ;; Returns u100

;; Calculate compound interest
(define-read-only (compound-interest (principal uint) (rate uint) (periods uint))
  (let ((rate-factor (+ u100 rate)))
    (/ (* principal (pow rate-factor periods)) (pow u100 periods))))
```

### sqrti \[#sqrti]

`sqrti` devuelve la raíz cuadrada entera de un número.

**Firma**

```clarity
(sqrti n)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `n` | `int` o `uint` | Número del que se quiere encontrar la raíz cuadrada |

```clarity
(sqrti u16) ;; Returns u4
(sqrti u100) ;; Returns u10
(sqrti 25) ;; Returns 5

;; Calculate distance (simplified)
(define-read-only (distance (x uint) (y uint))
  (sqrti (+ (* x x) (* y y))))
```

### log2 \[#log2]

`log2` devuelve el logaritmo en base 2 de un número.

**Firma**

```clarity
(log2 n)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `n` | `int` o `uint` | Número del que se quiere encontrar el logaritmo |

```clarity
(log2 u8) ;; Returns u3
(log2 u256) ;; Returns u8

;; Calculate bit position
(define-read-only (highest-bit-position (n uint))
  (if (> n u0)
    (some (log2 n))
    none))
```

### \< (menor que) \[#less-than]

`<` devuelve true si el primer argumento es menor que el segundo.

**Firma**

```clarity
(< i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Primer valor |
| `i2` | `int` o `uint` | Segundo valor |

```clarity
(< 5 10) ;; Returns true
(< u100 u50) ;; Returns false

;; Validate minimum
(define-public (deposit (amount uint))
  (begin
    (asserts! (< u0 amount) (err u1))
    (ok amount)))
```

### > (mayor que) \[#greater-than]

`>` devuelve true si el primer argumento es mayor que el segundo.

**Firma**

```clarity
(> i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Primer valor |
| `i2` | `int` o `uint` | Segundo valor |

```clarity
(> 10 5) ;; Returns true
(> u50 u100) ;; Returns false

;; Check maximum
(define-read-only (exceeds-limit (value uint))
  (> value u1000000))
```

### \<= (menor o igual) \[#less-than-or-equal]

`<=` devuelve verdadero si el primer argumento es menor o igual que el segundo.

**Firma**

```clarity
(<= i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Primer valor |
| `i2` | `int` o `uint` | Segundo valor |

```clarity
(<= 5 10) ;; Returns true
(<= 10 10) ;; Returns true
(<= u100 u50) ;; Returns false

;; Validate range
(define-read-only (is-valid-percentage (value uint))
  (and (<= u0 value) (<= value u100)))
```

### >= (mayor o igual que) \[#greater-than-or-equal]

`>=` devuelve verdadero si el primer argumento es mayor o igual que el segundo.

**Firma**

```clarity
(>= i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Primer valor |
| `i2` | `int` o `uint` | Segundo valor |

```clarity
(>= 10 5) ;; Returns true
(>= 10 10) ;; Returns true
(>= u50 u100) ;; Returns false

;; Check balance
(define-public (can-afford (price uint))
  (ok (>= (stx-get-balance tx-sender) price)))
```

## Operaciones lógicas \[#logical-operations]

### y \[#and]

`and` devuelve true si todos los argumentos son true.

**Firma**

```clarity
(and b1 b2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| b1, b2, ... | `bool` | Valores booleanos para evaluar |

```clarity
(and true true) ;; Returns true
(and true false) ;; Returns false
(and true true true) ;; Returns true

;; Multiple conditions
(define-read-only (is-valid-transfer (amount uint) (recipient principal))
  (and
    (> amount u0)
    (not (is-eq recipient tx-sender))
    (<= amount (get-balance tx-sender))))
```

### o \[#or]

`or` devuelve verdadero si al menos un argumento es verdadero.

**Firma**

```clarity
(or b1 b2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| b1, b2, ... | `bool` | Valores booleanos para evaluar |

```clarity
(or true false) ;; Returns true
(or false false) ;; Returns false
(or false false true) ;; Returns true

;; Check permissions
(define-read-only (can-access (user principal))
  (or
    (is-eq user contract-owner)
    (default-to false (map-get? admins user))
    (var-get public-access)))
```

### no \[#not]

`not` devuelve la negación lógica de un valor booleano.

**Firma**

```clarity
(not b)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `b` | `bool` | Valor booleano a negar |

```clarity
(not true) ;; Returns false
(not false) ;; Returns true

;; Check if not owner
(define-read-only (is-not-owner (user principal))
  (not (is-eq user contract-owner)))
```

### xor \[#xor]

`xor` devuelve verdadero si exactamente uno de los dos argumentos es verdadero.

**Firma**

```clarity
(xor b1 b2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `b1` | `bool` | Primer valor booleano |
| `b2` | `bool` | Segundo valor booleano |

```clarity
(xor true false) ;; Returns true
(xor true true) ;; Returns false
(xor false false) ;; Returns false

;; Exclusive access
(define-read-only (has-exclusive-role (is-admin bool) (is-moderator bool))
  (xor is-admin is-moderator))
```

### is-eq \[#is-eq]

`is-eq` devuelve true si todos los argumentos son iguales.

**Firma**

```clarity
(is-eq v1 v2...)
```

**Parámetros**

| Name | Type | Description |
|------|------|-------------|
| v1, v2, ... | any | Valores a comparar para igualdad |

```clarity
(is-eq 5 5) ;; Returns true
(is-eq "hello" "hello") ;; Returns true
(is-eq u10 u20) ;; Returns false
(is-eq 1 1 1) ;; Returns true

;; Check owner
(define-public (admin-only)
  (begin
    (asserts! (is-eq tx-sender contract-owner) (err u401))
    (ok true)))
```

## Operaciones de secuencia y cadena \[#sequence-string-operations]

### lista \[#list]

`list` construye una lista a partir de los valores proporcionados.

**Firma**

```clarity
(list v1 v2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| v1, v2, ... | any | Valores para incluir en la lista |

```clarity
(list 1 2 3) ;; Returns (1 2 3)
(list true false true) ;; Returns (true false true)

;; Create address list
(define-data-var admins (list 5 principal)
  (list 'SP1234... 'SP5678...))
```

### append \[#append]

`append` agrega un elemento al final de una lista.

**Firma**

```clarity
(append list-expr element)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `list-expr` | `list` | Lista a la que añadir |
| `element` | cualquiera | Elemento para agregar |

```clarity
(append (list 1 2) 3) ;; Returns (1 2 3)
(append (list) u10) ;; Returns (u10)

;; Add to list
(define-public (add-member (member principal))
  (let ((current-list (var-get members)))
    (match (as-max-len? (append current-list member) u100)
      new-list (begin
        (var-set members new-list)
        (ok true))
      (err u1))))
```

### concat \[#concat]

`concat` une dos secuencias del mismo tipo.

**Firma**

```clarity
(concat sequence1 sequence2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `sequence1` | sequence | Primera secuencia |
| `sequence2` | secuencia | Segunda secuencia |

```clarity
(concat "Hello " "World") ;; Returns "Hello World"
(concat 0x0102 0x0304) ;; Returns 0x01020304
(concat (list 1 2) (list 3 4)) ;; Returns (1 2 3 4)

;; Combine strings
(define-read-only (format-message (prefix (string-ascii 10)) (msg (string-ascii 50)))
  (concat prefix msg))
```

### len \[#len]

`len` devuelve la longitud de una secuencia.

**Firma**

```clarity
(len sequence)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `sequence` | sequence | Secuencia a medir |

```clarity
(len "Hello") ;; Returns u5
(len (list 1 2 3)) ;; Returns u3
(len 0x0102) ;; Returns u2

;; Validate length
(define-public (set-name (name (string-ascii 50)))
  (begin
    (asserts! (> (len name) u0) (err u1))
    (asserts! (<= (len name) u20) (err u2))
    (ok name)))
```

### element-at? \[#element-at?]

`element-at?` recupera un elemento en un índice específico.

**Firma**

```clarity
(element-at? sequence index)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `sequence` | secuencia | Secuencia para acceder |
| `index` | `uint` | Índice basado en cero |

```clarity
(element-at? "Hello" u1) ;; Returns (some "e")
(element-at? (list 10 20 30) u2) ;; Returns (some 30)
(element-at? (list 1 2) u5) ;; Returns none

;; Get from list safely
(define-read-only (get-member-at (index uint))
  (element-at? (var-get members) index))
```

### index-of? \[#index-of]

`index-of?` encuentra la primera aparición de un elemento en una secuencia.

**Firma**

```clarity
(index-of? sequence element)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `sequence` | secuencia | Secuencia a buscar |
| `element` | cualquiera | Elemento a encontrar |

```clarity
(index-of? "Hello" "l") ;; Returns (some u2)
(index-of? (list 1 2 3 2) 2) ;; Returns (some u1)
(index-of? (list 1 2 3) 5) ;; Returns none

;; Check membership
(define-read-only (is-member (user principal))
  (is-some (index-of? (var-get members) user)))
```

### slice? \[#slice]

`slice?` extrae una subsecuencia de una secuencia.

**Firma**

```clarity
(slice? sequence left-position right-position)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `sequence` | secuencia | Secuencia para cortar |
| `left-position` | `uint` | Índice inicial (inclusivo) |
| `right-position` | `uint` | Índice final (exclusivo) |

```clarity
(slice? "Hello World" u0 u5) ;; Returns (some "Hello")
(slice? (list 1 2 3 4 5) u1 u4) ;; Returns (some (2 3 4))

;; Extract substring
(define-read-only (get-prefix (text (string-ascii 100)) (length uint))
  (slice? text u0 length))
```

### replace-at? \[#replace-at]

`replace-at?` reemplaza un elemento en un índice específico.

**Firma**

```clarity
(replace-at? sequence index new-element)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `sequence` | secuencia | Secuencia a modificar |
| `index` | `uint` | Índice a reemplazar en |
| `new-element` | cualquier | Nuevo elemento |

```clarity
(replace-at? "Hello" u1 "a") ;; Returns (some "Hallo")
(replace-at? (list 1 2 3) u1 5) ;; Returns (some (1 5 3))

;; Update list element
(define-public (update-member (index uint) (new-member principal))
  (match (replace-at? (var-get members) index new-member)
    new-list (begin
      (var-set members new-list)
      (ok true))
    (err u404)))
```

### int-to-ascii \[#int-to-ascii]

`int-to-ascii` converts an integer to its ASCII string representation.

**Firma**

```clarity
(int-to-ascii value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | `int` o `uint` | Entero a convertir |

```clarity
(int-to-ascii 123) ;; Returns "123"
(int-to-ascii u456) ;; Returns "456"

;; Format ID
(define-read-only (format-id (id uint))
  (concat "ID-" (int-to-ascii id)))
```

### int-to-utf8 \[#int-to-utf8]

`int-to-utf8` convierte un número entero a su representación de cadena UTF-8.

**Firma**

```clarity
(int-to-utf8 value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | `int` o `uint` | Entero a convertir |

```clarity
(int-to-utf8 789) ;; Returns u"789"
(int-to-utf8 u100) ;; Returns u"100"

;; Create UTF-8 label
(define-read-only (create-label (num uint))
  (concat u"Label #" (int-to-utf8 num)))
```

### string-to-int? \[#string-to-int]

`string-to-int?` convierte una cadena a un entero opcional.

**Firma**

```clarity
(string-to-int? string)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `string` | `string-ascii` o `string-utf8` | Cadena para convertir |

```clarity
(string-to-int? "123") ;; Returns (some 123)
(string-to-int? "-456") ;; Returns (some -456)
(string-to-int? "abc") ;; Returns none

;; Parse user input
(define-public (set-value (input (string-ascii 10)))
  (match (string-to-int? input)
    value (ok (var-set stored-value value))
    (err u1)))
```

### string-to-uint? \[#string-to-uint]

`string-to-uint?` convierte una cadena a un número entero sin signo opcional.

**Firma**

```clarity
(string-to-uint? string)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `string` | `string-ascii` o `string-utf8` | Cadena para convertir |

```clarity
(string-to-uint? "123") ;; Returns (some u123)
(string-to-uint? "0") ;; Returns (some u0)
(string-to-uint? "-123") ;; Returns none

;; Parse amount
(define-read-only (parse-amount (input (string-ascii 20)))
  (string-to-uint? input))
```

### buff-to-int-be \[#buff-to-int-be]

`buff-to-int-be` convierte un búfer a un número entero con signo (big-endian).

**Firma**

```clarity
(buff-to-int-be buffer)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `buffer` | `buff` | Búfer a convertir |

```clarity
(buff-to-int-be 0x0001) ;; Returns 1
(buff-to-int-be 0x00ff) ;; Returns 255
(buff-to-int-be 0xffff) ;; Returns -1

;; Parse signed data
(define-read-only (parse-signed-data (data (buff 8)))
  (buff-to-int-be data))
```

### buff-to-int-le \[#buff-to-int-le]

`buff-to-int-le` convierte un búfer a un número entero con signo (little-endian).

**Firma**

```clarity
(buff-to-int-le buffer)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `buffer` | `buff` | Búfer a convertir |

```clarity
(buff-to-int-le 0x0100) ;; Returns 1
(buff-to-int-le 0xff00) ;; Returns 255

;; Parse little-endian data
(define-read-only (parse-le-data (data (buff 4)))
  (buff-to-int-le data))
```

### buff-to-uint-be \[#buff-to-uint-be]

`buff-to-uint-be` convierte un búfer a un número entero sin signo (big-endian).

**Firma**

```clarity
(buff-to-uint-be buffer)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `buffer` | `buff` | Búfer a convertir |

```clarity
(buff-to-uint-be 0x0001) ;; Returns u1
(buff-to-uint-be 0x0100) ;; Returns u256

;; Parse network data
(define-read-only (parse-network-uint (data (buff 8)))
  (buff-to-uint-be data))
```

### buff-to-uint-le \[#buff-to-uint-le]

`buff-to-uint-le` convierte un búfer a un número entero sin signo (little-endian).

**Firma**

```clarity
(buff-to-uint-le buffer)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `buffer` | `buff` | Búfer a convertir |

```clarity
(buff-to-uint-le 0x0100) ;; Returns u1
(buff-to-uint-le 0x0001) ;; Returns u256

;; Parse file data
(define-read-only (parse-file-size (data (buff 4)))
  (buff-to-uint-le data))
```

## Iteradores \[#iterators]

### mapa \[#map]

`map` aplica una función a cada elemento de una lista.

**Firma**

```clarity
(map func list1 list2...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `func` | función | Función a aplicar |
| lista1, lista2, ... | `list` | Listas para recorrer |

```clarity
(map + (list 1 2 3) (list 10 20 30)) ;; Returns (11 22 33)

;; Double all values
(define-private (double (x uint))
  (* x u2))

(define-read-only (double-all (numbers (list 10 uint)))
  (map double numbers))
```

### filtro \[#filter]

`filter` devuelve elementos que satisfacen un predicado.

**Firma**

```clarity
(filter func list)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `func` | función | Función de predicado |
| `list` | `list` | Lista para filtrar |

```clarity
(define-private (is-even (x uint))
  (is-eq (mod x u2) u0))

(filter is-even (list u1 u2 u3 u4)) ;; Returns (u2 u4)

;; Filter active users
(define-read-only (get-active-users)
  (filter is-active (var-get all-users)))
```

### plegar \[#fold]

`fold` reduce una lista a un solo valor.

**Firma**

```clarity
(fold func list initial-value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `func` | función | Función reductora |
| `list` | `list` | Lista para reducir |
| `initial-value` | cualquier | Valor inicial |

```clarity
(fold + (list u1 u2 u3 u4) u0) ;; Returns u10

;; Sum balances
(define-private (add-balance (user principal) (total uint))
  (+ total (default-to u0 (map-get? balances user))))

(define-read-only (get-total-balance)
  (fold add-balance (var-get users) u0))
```

## Almacenamiento de datos y variables \[#data-storage-variables]

### define-constant \[#define-constant]

`define-constant` crea un valor constante inmutable.

**Firma**

```clarity
(define-constant name value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `name` | símbolo | Nombre de la constante |
| `value` | cualquiera | Valor de la constante |

```clarity
(define-constant contract-owner tx-sender)
(define-constant token-name "MyToken")
(define-constant max-supply u1000000)

;; Use in functions
(define-read-only (get-owner)
  contract-owner)
```

### define-data-var \[#define-data-var]

`define-data-var` crea una variable de datos mutable.

**Firma**

```clarity
(define-data-var name type value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `name` | símbolo | Nombre de la variable |
| `type` | tipo | Tipo de la variable |
| `value` | cualquier | Valor inicial |

```clarity
(define-data-var counter uint u0)
(define-data-var is-paused bool false)
(define-data-var admin principal tx-sender)

;; Update variable
(define-public (increment)
  (begin
    (var-set counter (+ (var-get counter) u1))
    (ok (var-get counter))))
```

### var-get \[#var-get]

`var-get` recupera el valor de una variable de datos.

**Firma**

```clarity
(var-get name)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `name` | símbolo | Nombre de la variable |

```clarity
(define-data-var balance uint u100)

(define-read-only (get-balance)
  (var-get balance))

;; Use in calculations
(define-public (double-balance)
  (let ((current (var-get balance)))
    (var-set balance (* current u2))
    (ok (var-get balance))))
```

### var-set \[#var-set]

`var-set` actualiza el valor de una variable de datos.

**Firma**

```clarity
(var-set name value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `name` | símbolo | Nombre de la variable |
| `value` | cualquiera | Nuevo valor |

```clarity
(define-data-var counter uint u0)

(define-public (set-counter (value uint))
  (begin
    (var-set counter value)
    (ok true)))

;; Conditional update
(define-public (update-if-higher (value uint))
  (if (> value (var-get counter))
    (begin
      (var-set counter value)
      (ok true))
    (err u1)))
```

### define-map \[#define-map]

`define-map` crea un nuevo mapa de datos.

**Firma**

```clarity
(define-map name key-type value-type)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `name` | símbolo | Nombre del mapa |
| `key-type` | tipo | Tipo de las claves |
| `value-type` | tipo | Tipo de los valores |

```clarity
(define-map balances principal uint)
(define-map user-profiles
  principal
  {
    name: (string-ascii 50),
    age: uint,
    active: bool
  })

;; Composite key
(define-map allowances
  { owner: principal, spender: principal }
  uint)
```

### map-get? \[#map-get]

`map-get?` recupera un valor de un mapa.

**Firma**

```clarity
(map-get? map-name key)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `map-name` | símbolo | Nombre del mapa |
| `key` | cualquiera | Clave para buscar |

```clarity
(define-map balances principal uint)

(define-read-only (get-balance (user principal))
  (default-to u0 (map-get? balances user)))

;; Pattern matching
(define-read-only (get-profile-name (user principal))
  (match (map-get? user-profiles user)
    profile (get name profile)
    "Unknown"))
```

### map-set \[#map-set]

`map-set` establece o actualiza un valor en un mapa.

**Firma**

```clarity
(map-set map-name key value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `map-name` | símbolo | Nombre del mapa |
| `key` | cualquiera | Key to set |
| `value` | cualquier | Valor para almacenar |

```clarity
(define-map balances principal uint)

(define-public (set-balance (user principal) (amount uint))
  (begin
    (map-set balances user amount)
    (ok true)))

;; Update profile
(define-public (update-profile (name (string-ascii 50)) (age uint))
  (begin
    (map-set user-profiles tx-sender {
      name: name,
      age: age,
      active: true
    })
    (ok true)))
```

### map-insert \[#map-insert]

`map-insert` inserta un valor solo si la clave no existe.

**Firma**

```clarity
(map-insert map-name key value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `map-name` | símbolo | Nombre del mapa |
| `key` | cualquiera | Tecla para insertar |
| `value` | cualquier | Valor para almacenar |

```clarity
(define-map users principal { joined: uint })

(define-public (register)
  (if (map-insert users tx-sender { joined: block-height })
    (ok "Registered successfully")
    (err u409))) ;; Already exists

;; One-time initialization
(define-public (initialize-user (user principal))
  (begin
    (asserts! (map-insert balances user u1000) (err u1))
    (ok true)))
```

### map-delete \[#map-delete]

`map-delete` elimina un par clave-valor de un mapa.

**Firma**

```clarity
(map-delete map-name key)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `map-name` | símbolo | Nombre del mapa |
| `key` | cualquiera | Key to delete |

```clarity
(define-map users principal { data: uint })

(define-public (remove-user (user principal))
  (begin
    (asserts! (is-eq tx-sender contract-owner) (err u401))
    (map-delete users user)
    (ok true)))

;; Clear data
(define-public (clear-balance)
  (begin
    (map-delete balances tx-sender)
    (ok true)))
```

### define-private \[#define-private]

`define-private` crea una función privada que solo se puede llamar dentro del contrato.

**Firma**

```clarity
(define-private (function-name (arg-name arg-type)...) body)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `function-name` | símbolo | Nombre de la función |
| `arg-name` | símbolo | Nombres de argumentos |
| `arg-type` | tipo | Tipos de argumentos |
| `body` | expresión | Cuerpo de la función |

```clarity
(define-private (calculate-fee (amount uint))
  (/ (* amount u3) u100)) ;; 3% fee

(define-public (transfer-with-fee (recipient principal) (amount uint))
  (let ((fee (calculate-fee amount)))
    (try! (stx-transfer? (- amount fee) tx-sender recipient))
    (try! (stx-transfer? fee tx-sender contract-owner))
    (ok true)))

;; Helper functions
(define-private (is-valid-amount (amount uint))
  (and (> amount u0) (<= amount u1000000)))
```

### define-public \[#define-public]

`define-public` crea una función pública que se puede llamar desde fuera del contrato.

**Firma**

```clarity
(define-public (function-name (arg-name arg-type)...) body)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `function-name` | símbolo | Nombre de la función |
| `arg-name` | símbolo | Nombres de argumentos |
| `arg-type` | tipo | Tipos de argumentos |
| `body` | expresión | Cuerpo de la función (debe devolver respuesta) |

```clarity
(define-public (transfer (recipient principal) (amount uint))
  (begin
    (asserts! (not (is-eq tx-sender recipient)) (err u1))
    (asserts! (> amount u0) (err u2))
    (try! (ft-transfer? my-token amount tx-sender recipient))
    (ok true)))

;; State-changing function
(define-public (set-name (new-name (string-ascii 50)))
  (begin
    (map-set user-names tx-sender new-name)
    (ok new-name)))
```

### define-read-only \[#define-read-only]

`define-read-only` crea una función pública de solo lectura.

**Firma**

```clarity
(define-read-only (function-name (arg-name arg-type)...) body)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `function-name` | símbolo | Nombre de la función |
| `arg-name` | símbolo | Nombres de argumentos |
| `arg-type` | tipo | Tipos de argumentos |
| `body` | expresión | Cuerpo de la función |

```clarity
(define-read-only (get-balance (user principal))
  (default-to u0 (map-get? balances user)))

(define-read-only (calculate-reward (staked uint) (days uint))
  (/ (* staked days u5) u36500)) ;; ~5% APY

;; Complex query
(define-read-only (get-user-info (user principal))
  {
    balance: (get-balance user),
    profile: (map-get? user-profiles user),
    is-admin: (is-eq user contract-owner)
  })
```

## Manejo de errores \[#error-handling]

### ok \[#ok]

`ok` construye un valor de respuesta exitoso.

**Firma**

```clarity
(ok value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | cualquier | Valor de éxito |

```clarity
(ok u42) ;; Returns (ok u42)
(ok { status: "success", value: u100 })

;; Success response
(define-public (deposit (amount uint))
  (begin
    (map-set balances tx-sender
      (+ (get-balance tx-sender) amount))
    (ok amount)))
```

### err \[#err]

`err` construye un valor de respuesta de error.

**Firma**

```clarity
(err value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | cualquier | Valor de error |

```clarity
(err u404) ;; Returns (err u404)
(err { code: u500, message: "Internal error" })

;; Error responses
(define-public (withdraw (amount uint))
  (let ((balance (get-balance tx-sender)))
    (if (>= balance amount)
      (ok amount)
      (err u1)))) ;; Insufficient balance
```

### asserts! \[#asserts]

`asserts!` comprueba una condición y sale con un error si es falsa.

**Firma**

```clarity
(asserts! condition thrown-value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `condition` | `bool` | Condición a verificar |
| `thrown-value` | cualquiera | Valor a devolver si es falso |

```clarity
(define-public (transfer (amount uint) (recipient principal))
  (begin
    (asserts! (> amount u0) (err u1))
    (asserts! (not (is-eq tx-sender recipient)) (err u2))
    (asserts! (<= amount (get-balance tx-sender)) (err u3))
    (ok true)))

;; Guard functions
(define-public (admin-only-function)
  (begin
    (asserts! (is-eq tx-sender contract-owner) (err u401))
    ;; Admin logic here
    (ok true)))
```

### try! \[#try]

`try!` intenta desenvolver una respuesta, propagando cualquier error.

**Firma**

```clarity
(try! response)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `response` | respuesta | Respuesta para probar |

```clarity
(try! (ok u42)) ;; Returns u42
(try! (err u404)) ;; Propagates (err u404)

;; Chain operations
(define-public (complex-operation (amount uint))
  (begin
    (try! (check-preconditions amount))
    (try! (process-payment amount))
    (try! (update-records))
    (ok true)))
```

### unwrap! \[#unwrap]

`unwrap!` extrae el valor interno de una respuesta opcional o exitosa.

**Firma**

```clarity
(unwrap! optional-or-response thrown-value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `optional-or-response` | opcional/respuesta | Valor para desenvolver |
| `thrown-value` | cualquiera | Valor si ninguno/error |

```clarity
(unwrap! (some u42) (err u1)) ;; Returns u42
(unwrap! none (err u404)) ;; Throws (err u404)

;; Safe access
(define-public (transfer-from-map (recipient principal))
  (let ((amount (unwrap! (map-get? pending-transfers tx-sender) (err u404))))
    (try! (ft-transfer? token amount tx-sender recipient))
    (map-delete pending-transfers tx-sender)
    (ok amount)))
```

### unwrap-err! \[#unwrap-err]

`unwrap-err!` extrae el valor de error de una respuesta de error.

**Firma**

```clarity
(unwrap-err! response thrown-value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `response` | respuesta | Respuesta a desenvolver |
| `thrown-value` | cualquiera | Valor si está bien |

```clarity
(unwrap-err! (err u404) u0) ;; Returns u404
(unwrap-err! (ok u42) u0) ;; Returns u0

;; Error handling
(define-public (handle-error)
  (let ((error-code (unwrap-err! (process-action) u0)))
    (print { error: error-code })
    (ok error-code)))
```

### unwrap-panic \[#unwrap-panic]

`unwrap-panic` extrae un valor o provoca un pánico en tiempo de ejecución.

**Firma**

```clarity
(unwrap-panic optional-or-response)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `optional-or-response` | opcional/respuesta | Valor a desenvolver |

```clarity
(unwrap-panic (some u42)) ;; Returns u42
(unwrap-panic none) ;; Runtime panic

;; Critical unwrap
(define-read-only (get-critical-value)
  (unwrap-panic (map-get? critical-config "version")))
```

### unwrap-err-panic \[#unwrap-err-panic]

`unwrap-err-panic` extrae un valor de error o causa un pánico en tiempo de ejecución.

**Firma**

```clarity
(unwrap-err-panic response)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `response` | respuesta | Respuesta para desenvolver |

```clarity
(unwrap-err-panic (err u404)) ;; Returns u404
(unwrap-err-panic (ok u42)) ;; Runtime panic

;; Force error
(define-read-only (get-error-code)
  (unwrap-err-panic (always-fails)))
```

## Ayudantes de datos \[#data-helpers]

### default-to \[#default-to]

`default-to` devuelve un valor predeterminado para none.

**Firma**

```clarity
(default-to default optional)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `default` | cualquiera | Valor predeterminado |
| `optional` | opcional | Valor opcional |

```clarity
(default-to u0 (some u42)) ;; Returns u42
(default-to u0 none) ;; Returns u0

;; Safe defaults
(define-read-only (get-balance-safe (user principal))
  (default-to u0 (map-get? balances user)))
```

### fusionar \[#merge]

`merge` combina dos tuplas, con la segunda anulando la primera.

**Firma**

```clarity
(merge tuple1 tuple2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `tuple1` | tupla | Tupla base |
| `tuple2` | tupla | Anular tupla |

```clarity
(merge { a: u1, b: u2 } { b: u3, c: u4 })
;; Returns { a: u1, b: u3, c: u4 }

;; Update record
(define-public (update-profile (updates { name: (optional (string-ascii 50)), age: (optional uint) }))
  (let ((current (default-to { name: "", age: u0 } (map-get? profiles tx-sender))))
    (map-set profiles tx-sender (merge current updates))
    (ok true)))
```

### get \[#get]

`get` extrae un valor de una tupla por clave.

**Firma**

```clarity
(get key tuple)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `key` | símbolo | Clave para extraer |
| `tuple` | tupla | Tupla a la que acceder |

```clarity
(get balance { balance: u100, locked: u50 }) ;; Returns u100

;; Access nested data
(define-read-only (get-user-balance (user principal))
  (match (map-get? accounts user)
    account (get balance account)
    u0))
```

### as-max-len? \[#as-max-len]

`as-max-len?` comprueba si una secuencia se ajusta a una longitud máxima.

**Firma**

```clarity
(as-max-len? sequence max-length)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `sequence` | secuencia | Secuencia a verificar |
| `max-length` | uint | Longitud máxima permitida |

```clarity
(as-max-len? (list 1 2 3) u5) ;; Returns (some (1 2 3))
(as-max-len? "Hello" u3) ;; Returns none

;; Safe append
(define-public (add-to-list (item uint))
  (match (as-max-len? (append (var-get items) item) u100)
    new-list (begin
      (var-set items new-list)
      (ok true))
    (err u1)))
```

## Control de flujo \[#control-flow]

### si \[#if]

`if` evalúa una condición y devuelve uno de dos valores.

**Firma**

```clarity
(if condition true-branch false-branch)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `condition` | `bool` | Condición a evaluar |
| `true-branch` | cualquiera | Valor si es verdadero |
| `false-branch` | cualquiera | Valor si es falso |

```clarity
(if (> u10 u5)
  "Greater"
  "Not greater") ;; Returns "Greater"

;; Conditional logic
(define-public (withdraw (amount uint))
  (let ((balance (get-balance tx-sender)))
    (if (>= balance amount)
      (begin
        (map-set balances tx-sender (- balance amount))
        (ok amount))
      (err u1))))
```

### match \[#partido]

`match` realiza coincidencia de patrones en tipos opcionales y de respuesta.

**Firma**

```clarity
(match value
  some-name some-branch
  none-branch)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | opcional/respuesta | Valor a coincidir |
| `some-name` | símbolo | Enlace para algún valor |
| `some-branch` | expresión | Expresión si alguna |
| `none-branch` | expresión | Expresión si no hay ninguna |

```clarity
(match (map-get? balances tx-sender)
  balance (ok balance)
  (err u404))

;; Response matching
(match (ft-transfer? token u100 tx-sender recipient)
  success (ok "Transfer successful")
  error (err error))

;; Nested matching
(define-read-only (get-user-name (user principal))
  (match (map-get? user-profiles user)
    profile (match (get name profile)
      name (ok name)
      (err u1))
    (err u404)))
```

### begin \[#begin]

`begin` ejecuta múltiples expresiones en secuencia.

**Firma**

```clarity
(begin expr1 expr2... last-expr)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| expr1, expr2, ... | any | Expresiones a ejecutar |
| `last-expr` | cualquiera | Expresión final (valor de retorno) |

```clarity
(begin
  (print "Starting")
  (var-set counter u1)
  (ok true))

;; Multiple operations
(define-public (initialize)
  (begin
    (asserts! (is-eq tx-sender contract-owner) (err u401))
    (var-set is-initialized true)
    (map-set admins tx-sender true)
    (print { event: "initialized", by: tx-sender })
    (ok true)))
```

### let \[#let]

`let` crea enlaces locales para su uso en una expresión.

**Firma**

```clarity
(let ((name1 value1) (name2 value2)...) body)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `name` | símbolo | Nombre de enlace |
| `value` | cualquier | Valor para vincular |
| `body` | expresión | Expresión usando enlaces |

```clarity
(let ((x 10) (y 20))
  (+ x y)) ;; Returns 30

;; Complex calculations
(define-public (calculate-reward (days uint))
  (let (
    (balance (get-balance tx-sender))
    (rate u5) ;; 5% annual
    (reward (/ (* balance rate days) u36500)))
    (begin
      (map-set rewards tx-sender reward)
      (ok reward))))
```

## Tipos opcionales y de respuesta \[#optional-response-types]

### algunos \[#some]

`some` construye un valor opcional que contiene un valor.

**Firma**

```clarity
(some value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | cualquiera | Valor para envolver |

```clarity
(some u42) ;; Returns (some u42)
(some "Hello") ;; Returns (some "Hello")

;; Return optional
(define-read-only (find-user (id uint))
  (if (map-get? users id)
    (some (map-get? users id))
    none))
```

### is-ok \[#is-ok]

`is-ok` comprueba si una respuesta es correcta.

**Firma**

```clarity
(is-ok response)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `response` | respuesta | Respuesta a verificar |

```clarity
(is-ok (ok u42)) ;; Returns true
(is-ok (err u1)) ;; Returns false

;; Check success
(define-read-only (was-successful (tx-id uint))
  (is-ok (map-get? transaction-results tx-id)))
```

### is-err \[#is-err]

`is-err` comprueba si una respuesta es err.

**Firma**

```clarity
(is-err response)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `response` | respuesta | Respuesta a verificar |

```clarity
(is-err (err u404)) ;; Returns true
(is-err (ok u42)) ;; Returns false

;; Check failure
(define-read-only (has-error (result (response uint uint)))
  (is-err result))
```

### is-some \[#is-some]

`is-some` comprueba si un opcional contiene un valor.

**Firma**

```clarity
(is-some optional)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `optional` | opcional | Opcional para verificar |

```clarity
(is-some (some u42)) ;; Returns true
(is-some none) ;; Returns false

;; Check existence
(define-read-only (user-exists (user principal))
  (is-some (map-get? users user)))
```

### is-none \[#is-none]

`is-none` comprueba si un opcional es none.

**Firma**

```clarity
(is-none optional)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `optional` | opcional | Opcional para verificar |

```clarity
(is-none none) ;; Returns true
(is-none (some u42)) ;; Returns false

;; Check absence
(define-read-only (is-available (name (string-ascii 50)))
  (is-none (map-get? reserved-names name)))
```

## Tokens fungibles \[#fungible-tokens]

### define-fungible-token \[#define-fungible-token]

`define-fungible-token` crea un nuevo token fungible.

**Firma**

```clarity
(define-fungible-token token-name [total-supply])
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token-name` | symbol | Nombre del token |
| `total-supply` | `uint` (opcional) | Suministro máximo |

```clarity
(define-fungible-token my-token)
(define-fungible-token limited-token u1000000)

;; With helper functions
(define-public (get-balance (user principal))
  (ok (ft-get-balance my-token user)))
```

### ft-mint? \[#ft-mint]

`ft-mint?` crea nuevos tokens para un destinatario.

**Firma**

```clarity
(ft-mint? token amount recipient)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | Token para acuñar |
| `amount` | `uint` | Cantidad a acuñar |
| `recipient` | `principal` | Destinatario de tokens |

```clarity
(ft-mint? my-token u100 tx-sender)

;; Mint with checks
(define-public (mint-tokens (amount uint) (recipient principal))
  (begin
    (asserts! (is-eq tx-sender contract-owner) (err u401))
    (ft-mint? my-token amount recipient)))
```

### ft-burn? \[#ft-burn]

`ft-burn?` destruye tokens de un propietario.

**Firma**

```clarity
(ft-burn? token amount owner)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | Token para quemar |
| `amount` | `uint` | Cantidad para quemar |
| `owner` | `principal` | Propietario de tokens |

```clarity
(ft-burn? my-token u50 tx-sender)

;; Burn own tokens
(define-public (burn (amount uint))
  (ft-burn? my-token amount tx-sender))
```

### ft-transfer? \[#ft-transfer]

`ft-transfer?` transfiere tokens entre principales.

**Firma**

```clarity
(ft-transfer? token amount sender recipient)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | Token a transferir |
| `amount` | `uint` | Cantidad a transferir |
| `sender` | `principal` | Remitente |
| `recipient` | `principal` | Destinatario |

```clarity
(ft-transfer? my-token u50 tx-sender recipient)

;; Transfer with memo
(define-public (transfer-memo (amount uint) (recipient principal) (memo (buff 32)))
  (begin
    (print { action: "transfer", amount: amount, memo: memo })
    (ft-transfer? my-token amount tx-sender recipient)))
```

### ft-get-balance \[#ft-get-balance]

`ft-get-balance` devuelve el saldo de tokens de un principal.

**Firma**

```clarity
(ft-get-balance token principal)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | Token a consultar |
| `principal` | `principal` | Cuenta a verificar |

```clarity
(ft-get-balance my-token tx-sender) ;; Returns uint

;; Balance check
(define-read-only (has-sufficient-balance (user principal) (required uint))
  (>= (ft-get-balance my-token user) required))
```

### ft-get-supply \[#ft-get-supply]

`ft-get-supply` devuelve el suministro actual de tokens.

**Firma**

```clarity
(ft-get-supply token)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | Token a consultar |

```clarity
(ft-get-supply my-token) ;; Returns uint

;; Supply metrics
(define-read-only (get-supply-info)
  {
    current: (ft-get-supply my-token),
    max: u1000000,
    remaining: (- u1000000 (ft-get-supply my-token))
  })
```

## Tokens no fungibles \[#non-fungible-tokens]

### define-non-fungible-token \[#define-non-fungible-token]

`define-non-fungible-token` crea un nuevo token no fungible.

**Firma**

```clarity
(define-non-fungible-token token-name identifier-type)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token-name` | symbol | Nombre del NFT |
| `identifier-type` | tipo | Tipo del identificador |

```clarity
(define-non-fungible-token my-nft uint)
(define-non-fungible-token complex-nft { id: uint, serial: (buff 20) })

;; NFT with metadata
(define-map nft-metadata uint {
  name: (string-ascii 50),
  uri: (string-ascii 200)
})
```

### nft-mint? \[#nft-mint]

`nft-mint?` crea un nuevo NFT para un destinatario.

**Firma**

```clarity
(nft-mint? token identifier recipient)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | NFT para acuñar |
| `identifier` | cualquier | Identificador único |
| `recipient` | `principal` | Destinatario |

```clarity
(nft-mint? my-nft u1 tx-sender)

;; Mint with metadata
(define-public (mint-with-metadata (id uint) (name (string-ascii 50)) (uri (string-ascii 200)))
  (begin
    (try! (nft-mint? my-nft id tx-sender))
    (map-set nft-metadata id { name: name, uri: uri })
    (ok id)))
```

### nft-burn? \[#nft-burn]

`nft-burn?` destruye un NFT.

**Firma**

```clarity
(nft-burn? token identifier owner)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | NFT para quemar |
| `identifier` | cualquier | identificador de NFT |
| `owner` | `principal` | Propietario actual |

```clarity
(nft-burn? my-nft u1 tx-sender)

;; Burn with ownership check
(define-public (burn-nft (id uint))
  (let ((owner (unwrap! (nft-get-owner? my-nft id) (err u404))))
    (asserts! (is-eq owner tx-sender) (err u403))
    (nft-burn? my-nft id tx-sender)))
```

### nft-transfer? \[#nft-transfer]

`nft-transfer?` transfiere un NFT entre principales.

**Firma**

```clarity
(nft-transfer? token identifier sender recipient)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | NFT a transferir |
| `identifier` | cualquier | identificador de NFT |
| `sender` | `principal` | Propietario actual |
| `recipient` | `principal` | Nuevo propietario |

```clarity
(nft-transfer? my-nft u1 tx-sender recipient)

;; Safe transfer
(define-public (transfer (id uint) (recipient principal))
  (let ((owner (unwrap! (nft-get-owner? my-nft id) (err u404))))
    (asserts! (is-eq owner tx-sender) (err u403))
    (nft-transfer? my-nft id tx-sender recipient)))
```

### nft-get-owner? \[#nft-get-owner]

`nft-get-owner?` devuelve el propietario de un NFT.

**Firma**

```clarity
(nft-get-owner? token identifier)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `token` | token-name | NFT a consultar |
| `identifier` | cualquier | identificador de NFT |

```clarity
(nft-get-owner? my-nft u1) ;; Returns (optional principal)

;; Ownership check
(define-read-only (is-owner (id uint) (user principal))
  (match (nft-get-owner? my-nft id)
    owner (is-eq owner user)
    false))
```

## Operaciones STX \[#stx-operations]

### stx-transfer? \[#stx-transfer]

`stx-transfer?` transfiere STX entre direcciones.

**Firma**

```clarity
(stx-transfer? amount sender recipient)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `amount` | `uint` | Cantidad en microSTX |
| `sender` | `principal` | Dirección del remitente |
| `recipient` | `principal` | Dirección del destinatario |

```clarity
(stx-transfer? u1000000 tx-sender recipient) ;; Transfer 1 STX

;; Payment function
(define-public (pay (amount uint) (recipient principal))
  (begin
    (asserts! (> amount u0) (err u1))
    (stx-transfer? amount tx-sender recipient)))
```

### stx-transfer-memo? \[#stx-transfer-memo]

`stx-transfer-memo?` transfiere STX con un memo.

**Firma**

```clarity
(stx-transfer-memo? amount sender recipient memo)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `amount` | `uint` | Cantidad en microSTX |
| `sender` | `principal` | Dirección del remitente |
| `recipient` | `principal` | Dirección del destinatario |
| `memo` | `(buff 34)` | Memo de transferencia |

```clarity
(stx-transfer-memo? u1000000 tx-sender recipient 0x12345678)

;; Payment with reference
(define-public (pay-invoice (amount uint) (recipient principal) (invoice-id (buff 16)))
  (stx-transfer-memo? amount tx-sender recipient
    (concat 0x494e56 invoice-id))) ;; "INV" prefix
```

### stx-burn? \[#stx-burn]

`stx-burn?` quema STX enviándolo a una dirección de quemado.

**Firma**

```clarity
(stx-burn? amount sender)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `amount` | `uint` | Cantidad para quemar |
| `sender` | `principal` | Dirección quemando STX |

```clarity
(stx-burn? u1000000 tx-sender)

;; Burn mechanism
(define-public (burn-stx (amount uint))
  (begin
    (asserts! (> amount u0) (err u1))
    (stx-burn? amount tx-sender)))
```

### stx-get-balance \[#stx-get-balance]

`stx-get-balance` devuelve el saldo de STX de una dirección.

**Firma**

```clarity
(stx-get-balance principal)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `principal` | `principal` | Dirección a verificar |

```clarity
(stx-get-balance tx-sender) ;; Returns uint

;; Balance check
(define-read-only (can-afford-fee (user principal) (fee uint))
  (>= (stx-get-balance user) fee))
```

### stx-account \[#stx-account]

`stx-account` devuelve información detallada de la cuenta.

**Firma**

```clarity
(stx-account principal)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `principal` | `principal` | Dirección para consultar |

```clarity
(stx-account tx-sender)
;; Returns { locked: uint, unlock-height: uint, unlocked: uint }

;; Get available balance
(define-read-only (get-available-balance (user principal))
  (get unlocked (stx-account user)))
```

## Funciones criptográficas \[#cryptographic-functions]

### sha256 \[#sha256]

`sha256` calcula el hash SHA-256 de los datos de entrada.

**Firma**

```clarity
(sha256 data)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `data` | secuencia | Datos para hacer hash |

```clarity
(sha256 0x616263) ;; Returns SHA-256 of "abc"
(sha256 "Hello") ;; Hash string

;; Create hash commitment
(define-public (commit-hash (data (buff 32)))
  (let ((hash (sha256 data)))
    (map-set commitments tx-sender hash)
    (ok hash)))
```

### sha512 \[#sha512]

`sha512` calcula el hash SHA-512 de los datos de entrada.

**Firma**

```clarity
(sha512 data)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `data` | secuencia | Datos para hacer hash |

```clarity
(sha512 0x616263) ;; Returns SHA-512 hash
(sha512 "data") ;; Hash string

;; High security hash
(define-read-only (secure-hash (input (buff 1024)))
  (sha512 input))
```

### sha512/256 \[#sha512-256]

`sha512/256` calcula el hash SHA-512/256 de los datos de entrada.

**Firma**

```clarity
(sha512/256 data)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `data` | secuencia | Datos para hacer hash |

```clarity
(sha512/256 0x616263) ;; Returns 256-bit hash
(sha512/256 "secure") ;; Hash string

;; Merkle tree node
(define-private (hash-pair (left (buff 32)) (right (buff 32)))
  (sha512/256 (concat left right)))
```

### keccak256 \[#keccak256]

`keccak256` calcula el hash Keccak-256 de los datos de entrada.

**Firma**

```clarity
(keccak256 data)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `data` | secuencia | Datos para hacer hash |

```clarity
(keccak256 0x616263) ;; Returns Keccak-256 hash
(keccak256 "ethereum") ;; Hash string

;; Ethereum compatibility
(define-read-only (eth-compatible-hash (data (buff 256)))
  (keccak256 data))
```

### hash160 \[#hash160]

`hash160` computes RIPEMD160(SHA256(data)).

**Firma**

```clarity
(hash160 data)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `data` | secuencia | Datos para hacer hash |

```clarity
(hash160 0x616263) ;; Returns 160-bit hash
(hash160 "address") ;; Hash string

;; Bitcoin-style address
(define-read-only (create-hash160-id (data (buff 32)))
  (hash160 data))
```

### secp256k1-verify \[#secp256k1-verify]

`secp256k1-verify` verifica una firma contra un hash de mensaje.

**Firma**

```clarity
(secp256k1-verify hash signature public-key)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `hash` | `(buff 32)` | Hash del mensaje |
| `signature` | `(buff 65)` | Firma |
| `public-key` | `(buff 33)` | Clave pública |

```clarity
(secp256k1-verify
  0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
  signature
  public-key) ;; Returns bool

;; Signature verification
(define-public (verify-signature (hash (buff 32)) (sig (buff 65)) (pubkey (buff 33)))
  (ok (secp256k1-verify hash sig pubkey)))
```

### secp256k1-recover? \[#secp256k1-recover]

`secp256k1-recover?` recupera una clave pública a partir de una firma.

**Firma**

```clarity
(secp256k1-recover? hash signature)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `hash` | `(buff 32)` | Hash del mensaje |
| `signature` | `(buff 65)` | Firma |

```clarity
(secp256k1-recover? message-hash signature)
;; Returns (optional (buff 33))

;; Recover signer
(define-read-only (recover-signer (hash (buff 32)) (sig (buff 65)))
  (secp256k1-recover? hash sig))
```

## Datos de blockchain \[#blockchain-data]

### get-block-info? \[#get-block-info]

`get-block-info?` recupera información sobre un bloque.

**Firma**

```clarity
(get-block-info? property block)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `property` | Nombre de la propiedad | Propiedad a recuperar |
| `block` | `uint` | Altura del bloque |

Propiedades: `header-hash`, `burnchain-header-hash`, `time`, `miner-address`, `block-reward`, `miner-spend-total`, `miner-spend-winner`

```clarity
(get-block-info? time u100) ;; Returns (optional uint)
(get-block-info? miner-address u200) ;; Returns (optional principal)

;; Get block time
(define-read-only (get-block-timestamp (height uint))
  (get-block-info? time height))
```

### get-burn-block-info? \[#get-burn-block-info]

`get-burn-block-info?` recupera información del bloque de Bitcoin.

**Firma**

```clarity
(get-burn-block-info? property block)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `property` | Nombre de la propiedad | Propiedad a recuperar |
| `block` | `uint` | Altura del bloque de quemado |

Propiedades: `header-hash`, `pox-addrs`

```clarity
(get-burn-block-info? header-hash u100) ;; Returns (optional (buff 32))

;; Get burn block hash
(define-read-only (get-btc-header-hash (height uint))
  (get-burn-block-info? header-hash height))
```

### get-stacks-block-info? \[#get-stacks-block-info]

`get-stacks-block-info?` recupera información del bloque de Stacks.

**Firma**

```clarity
(get-stacks-block-info? property block)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `property` | Nombre de la propiedad | Propiedad a recuperar |
| `block` | `uint` | Altura del bloque de Stacks |

Propiedades: `header-hash`, `block-hash`, `miner-address`, `block-reward`

```clarity
(get-stacks-block-info? block-hash u100) ;; Returns (optional (buff 32))

;; Get stacks block data
(define-read-only (get-stacks-block-hash (height uint))
  (get-stacks-block-info? block-hash height))
```

### get-tenure-info? \[#get-tenure-info]

`get-tenure-info?` recupera información sobre la tenencia.

**Firma**

```clarity
(get-tenure-info? property block)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `property` | Nombre de la propiedad | Propiedad a recuperar |
| `block` | `uint` | Bloque de tenencia |

Propiedades: `burnchain-header-hash`, `miner-address`, `time`, `vrf-seed`

```clarity
(get-tenure-info? vrf-seed u100) ;; Returns (optional (buff 32))

;; Get tenure VRF seed
(define-read-only (get-vrf-seed (tenure uint))
  (get-tenure-info? vrf-seed tenure))
```

### at-block \[#at-block]

`at-block` evalúa una expresión en un contexto de bloque específico.

**Firma**

```clarity
(at-block block-hash expr)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `block-hash` | `(buff 32)` | Hash del bloque |
| `expr` | expresión | Expresión a evaluar |

```clarity
(at-block 0x1234... (var-get counter)) ;; Get historical value

;; Historical balance
(define-read-only (get-balance-at-block (user principal) (block-hash (buff 32)))
  (at-block block-hash (ft-get-balance my-token user)))
```

## Operaciones principales y de contrato \[#principal-contract-operations]

### principal-construct? \[#principal-construct]

`principal-construct?` crea un principal a partir de componentes de dirección.

**Firma**

```clarity
(principal-construct? version-byte hash)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `version-byte` | `(buff 1)` | Byte de versión |
| `hash` | `(buff 20)` | Hash de dirección |

```clarity
(principal-construct? 0x16 0x1234567890abcdef1234567890abcdef12345678)
;; Returns (optional principal)

;; Construct address
(define-read-only (make-principal (version (buff 1)) (hash (buff 20)))
  (principal-construct? version hash))
```

### principal-destruct? \[#principal-destruct]

`principal-destruct?` descompone un principal en componentes.

**Firma**

```clarity
(principal-destruct? principal)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `principal` | `principal` | Principal a descomponer |

```clarity
(principal-destruct? tx-sender)
;; Returns (optional { version: (buff 1), hash: (buff 20) })

;; Get address components
(define-read-only (get-principal-parts (user principal))
  (principal-destruct? user))
```

### principal-of? \[#principal-of]

`principal-of?` devuelve el principal de una clave pública.

**Firma**

```clarity
(principal-of? public-key)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `public-key` | `(buff 33)` | Clave pública |

```clarity
(principal-of? 0x0234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef12)
;; Returns (optional principal)

;; Derive address
(define-read-only (pubkey-to-principal (pubkey (buff 33)))
  (principal-of? pubkey))
```

### contract-call? \[#contract-call]

`contract-call?` llama a una función pública en otro contrato.

**Firma**

```clarity
(contract-call? contract function-name args...)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `contract` | principal | Contrato a llamar |
| `function-name` | símbolo | Nombre de la función |
| `args` | cualquier | Argumentos de función |

```clarity
(contract-call? .other-contract transfer u100 tx-sender recipient)

;; Cross-contract call
(define-public (forward-call (amount uint))
  (contract-call? .token-contract transfer amount tx-sender contract-owner))
```

### as-contract \[#as-contract]

`as-contract` ejecuta una expresión con el contrato como tx-sender.

**Firma**

```clarity
(as-contract expr)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `expr` | expresión | Expresión a ejecutar |

```clarity
(as-contract (stx-transfer? u1000 tx-sender recipient))

;; Contract-owned transfers
(define-public (withdraw-fees (recipient principal))
  (let ((balance (stx-get-balance (as-contract tx-sender))))
    (as-contract (stx-transfer? balance tx-sender recipient))))
```

### contrato-de \[#contract-of]

`contract-of` devuelve el principal de una referencia de trait.

**Firma**

```clarity
(contract-of trait-ref)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `trait-ref` | rasgo | Referencia de rasgo |

```clarity
(contract-of token-trait) ;; Returns principal

;; Get implementation
(define-read-only (get-token-contract)
  (contract-of deployed-token))
```

### es-estándar \[#is-standard]

`is-standard` verifica si un principal coincide con el tipo de red actual y puede gastar tokens.

**Firma**

```clarity
(is-standard standard-or-contract-principal)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `standard-or-contract-principal` | `principal` | Principal a verificar |

```clarity
;; On testnet
(is-standard 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6) ;; Returns true
(is-standard 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.foo) ;; Returns true
(is-standard 'SP3X6QWWETNBZWGBK6DRGTR1KX50S74D3433WDGJY) ;; Returns false

;; On mainnet
(is-standard 'SP3X6QWWETNBZWGBK6DRGTR1KX50S74D3433WDGJY) ;; Returns true
(is-standard 'SP3X6QWWETNBZWGBK6DRGTR1KX50S74D3433WDGJY.foo) ;; Returns true
(is-standard 'STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6) ;; Returns false
```

Puntos clave:

* Comprueba si un principal puede gastar tokens en la red actual
* Mainnet: Solo `SP` y `SM` las direcciones pueden gastar
* Testnet: Solo `ST` y `SN` las direcciones pueden gastar
* Todas las direcciones pueden recibir tokens, pero solo los tipos de red coincidentes pueden gastarlos
* Disponible a partir de Stacks 2.1

```clarity
;; Network-aware validation
(define-read-only (can-spend-on-network (address principal))
  (is-standard address))

;; Check if address matches network before allowing spending
(define-public (network-aware-transfer (recipient principal) (amount uint))
  (begin
    (asserts! (is-standard tx-sender) (err u401))
    (asserts! (is-standard recipient) (err u402))
    ;; Transfer logic
    (ok true)))
```

## Rasgos \[#traits]

### define-trait \[#define-trait]

`define-trait` crea una nueva definición de rasgo.

**Firma**

```clarity
(define-trait trait-name ((function-name (args...) response-type)...))
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `trait-name` | símbolo | Nombre del rasgo |
| `function-name` | símbolo | Firmas de funciones |

```clarity
(define-trait fungible-token (
  (transfer (uint principal principal) (response bool uint))
  (get-balance (principal) (response uint uint))
))

;; NFT trait
(define-trait nft-trait (
  (transfer (uint principal principal) (response bool uint))
  (get-owner (uint) (response (optional principal) uint))
))
```

### impl-trait \[#impl-trait]

`impl-trait` declara que un contrato implementa un rasgo.

**Firma**

```clarity
(impl-trait trait-identifier)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `trait-identifier` | trait | Rasgo a implementar |

```clarity
(impl-trait .token-trait.fungible-token)

;; Multiple traits
(impl-trait .dao-traits.proposal-trait)
(impl-trait .dao-traits.voting-trait)
```

### use-trait \[#use-trait]

`use-trait` crea un alias de rasgo para usar en funciones.

**Firma**

```clarity
(use-trait alias trait-identifier)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `alias` | símbolo | Alias local |
| `trait-identifier` | rasgo | Rasgo a alias |

```clarity
(use-trait token-trait .token-trait.fungible-token)

(define-public (swap (token <token-trait>) (amount uint))
  (contract-call? token transfer amount tx-sender .pool))
```

## Conversiones de tipo \[#type-conversions]

### to-int \[#to-int]

`to-int` convierte un número entero sin signo a un número entero con signo.

**Firma**

```clarity
(to-int uint)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `uint` | `uint` | Entero sin signo |

```clarity
(to-int u100) ;; Returns 100
(to-int u0) ;; Returns 0

;; Convert for calculations
(define-read-only (calculate-delta (a uint) (b uint))
  (- (to-int a) (to-int b)))
```

### to-uint \[#to-uint]

`to-uint` convierte un número entero con signo a un número entero sin signo.

**Firma**

```clarity
(to-uint int)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `int` | `int` | Número entero con signo |

```clarity
(to-uint 100) ;; Returns u100
(to-uint -50) ;; Causes runtime error

;; Safe conversion
(define-read-only (safe-to-uint (value int))
  (if (>= value 0)
    (some (to-uint value))
    none))
```

### to-consensus-buff? \[#to-consensus-buff]

`to-consensus-buff?` serializa un valor al formato de consenso.

**Firma**

```clarity
(to-consensus-buff? value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | cualquier | Valor para serializar |

```clarity
(to-consensus-buff? u100) ;; Returns (optional (buff 3))
(to-consensus-buff? { a: u1, b: u2 }) ;; Serializes tuple

;; Create hash of data
(define-read-only (hash-value (data uint))
  (match (to-consensus-buff? data)
    buff (sha256 buff)
    0x00))
```

### from-consensus-buff? \[#from-consensus-buff]

`from-consensus-buff?` deserializa desde el formato de consenso.

**Firma**

```clarity
(from-consensus-buff? type buffer)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `type` | tipo-firma | Tipo esperado |
| `buffer` | `buff` | Buffer a deserializar |

```clarity
(from-consensus-buff? uint 0x0100) ;; Returns (optional u1)
(from-consensus-buff? { a: uint, b: uint } buff) ;; Deserialize tuple

;; Parse stored data
(define-read-only (decode-data (data (buff 128)))
  (from-consensus-buff? { value: uint, timestamp: uint } data))
```

## Operaciones de bits \[#bit-operations]

### bit-and \[#bit-and]

`bit-and` realiza la operación AND a nivel de bits.

**Firma**

```clarity
(bit-and i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Primer valor |
| `i2` | `int` o `uint` | Segundo valor |

```clarity
(bit-and u12 u10) ;; Returns u8 (1100 & 1010 = 1000)
(bit-and 0xFF 0x0F) ;; Returns 0x0F

;; Check flags
(define-read-only (has-permission (flags uint) (permission uint))
  (> (bit-and flags permission) u0))
```

### bit-or \[#bit-or]

`bit-or` realiza la operación OR a nivel de bits.

**Firma**

```clarity
(bit-or i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Primer valor |
| `i2` | `int` o `uint` | Segundo valor |

```clarity
(bit-or u12 u10) ;; Returns u14 (1100 | 1010 = 1110)
(bit-or 0xF0 0x0F) ;; Returns 0xFF

;; Set flags
(define-public (add-permission (current uint) (new-permission uint))
  (ok (bit-or current new-permission)))
```

### bit-xor \[#bit-xor]

`bit-xor` realiza la operación XOR a nivel de bits.

**Firma**

```clarity
(bit-xor i1 i2)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i1` | `int` o `uint` | Primer valor |
| `i2` | `int` o `uint` | Segundo valor |

```clarity
(bit-xor u12 u10) ;; Returns u6 (1100 ^ 1010 = 0110)
(bit-xor 0xFF 0xFF) ;; Returns 0x00

;; Toggle flags
(define-public (toggle-flag (flags uint) (flag uint))
  (ok (bit-xor flags flag)))
```

### bit-not \[#bit-not]

`bit-not` realiza la operación de NOT a nivel de bits.

**Firma**

```clarity
(bit-not i)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i` | `int` o `uint` | Valor a invertir |

```clarity
(bit-not u0) ;; Returns maximum uint
(bit-not 0xFF) ;; Returns -256

;; Invert permissions
(define-read-only (get-inverse-permissions (permissions uint))
  (bit-not permissions))
```

### bit-shift-left \[#bit-shift-left]

`bit-shift-left` desplaza bits hacia la izquierda.

**Firma**

```clarity
(bit-shift-left i positions)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i` | `int` o `uint` | Valor a desplazar |
| `positions` | `uint` | Posiciones para desplazar |

```clarity
(bit-shift-left u1 u3) ;; Returns u8 (1 << 3)
(bit-shift-left u5 u2) ;; Returns u20

;; Calculate power of 2
(define-read-only (pow2 (exponent uint))
  (bit-shift-left u1 exponent))
```

### bit-shift-right \[#bit-shift-right]

`bit-shift-right` desplaza bits hacia la derecha.

**Firma**

```clarity
(bit-shift-right i positions)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `i` | `int` o `uint` | Valor a desplazar |
| `positions` | `uint` | Posiciones para desplazar |

```clarity
(bit-shift-right u8 u3) ;; Returns u1 (8 >> 3)
(bit-shift-right u20 u2) ;; Returns u5

;; Fast division by power of 2
(define-read-only (div-pow2 (value uint) (exponent uint))
  (bit-shift-right value exponent))
```

## Funciones de utilidad \[#utility-functions]

### print \[#print]

`print` devuelve un valor y lo retorna.

**Firma**

```clarity
(print value)
```

**Parámetros**

| Nombre | Tipo | Descripción |
|------|------|-------------|
| `value` | cualquiera | Valor a imprimir |

```clarity
(print "Debug message") ;; Prints and returns "Debug message"
(print { event: "transfer", amount: u100 })

;; Debug function
(define-public (debug-transfer (amount uint))
  (begin
    (print { function: "transfer", amount: amount, sender: tx-sender })
    (ok true)))
```
