---
title: Uso de fuentes de precios de Pyth
description: Guía completa para integrar datos de precios de mercado en tiempo real de Pyth Network en sus aplicaciones de Stacks.
---
import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Steps, Step } from '@/components/steps';
import { ArrowRight, Check } from 'lucide-react';

## Visión general

Esta guía completa le guía a través de la integración [Red Pyth](https://pyth.network)'s oráculo descentralizado para datos de precios en tiempo real en tus aplicaciones de Stacks. Construiremos un ejemplo completo: un NFT que solo se puede acuñar pagando exactamente $100 en valor de sBTC.

:::callout
The Pyth protocol integration is available as a Beta on both testnet and mainnet networks. It's maintained by Trust Machines and provides access to real-time price feeds for BTC, STX, ETH, and USDC.
:::

## Descripción general de la arquitectura

Pyth Network utiliza una única **basado en pull** diseño de oráculo:

<Mermaid
  chart="
graph LR
A[Red Pyth] -->|Datos de precio| B[Wormhole]
B -->|Mensajes VAA| C[API de Hermes]
C -->|Obtener VAA| D[Tu Frontend]
D -->|Enviar VAA + TX| E[Cadena Stacks]
E -->|Verificar y Actualizar| F[Contrato Oracle de Pyth]
F -->|Precio actualizado| G[Tu Contrato]

style A fill:#FF7733,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style C fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style D fill:#F5F5F5,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style E fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style F fill:#C2EBC4,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style G fill:#C2EBC4,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c"
/>

A diferencia de los oráculos basados en push que actualizan continuamente los precios en la cadena, Pyth permite a los usuarios obtener y enviar actualizaciones de precios solo cuando es necesario, lo que lo hace más eficiente en términos de gas.

## Lo que estamos construyendo

Crearemos un "Benjamin Club" - un NFT exclusivo que cuesta exactamente $100 en valor de sBTC para acuñar. Esto demuestra:

* Lectura de precios BTC/USD en tiempo real desde Pyth
* Conversión entre cantidades de USD y criptomonedas
* Manejo de aritmética de punto fijo
* Construyendo una integración frontend completa
* Probando contratos dependientes de oráculo

<Files className="font-mono pointer-events-none bg-background">
  <Folder name="benjamin-club" defaultOpen>
    <Folder name="contracts" defaultOpen>
      <File name="benjamin-club.clar" />

      <File name="sbtc-token.clar" />
    </Folder>

    <Folder name="frontend" defaultOpen>
      <File name="MintButton.tsx" />

      <File name="pyth-service.ts" />
    </Folder>

    <Folder name="tests" defaultOpen>
      <File name="benjamin-club.test.ts" />

      <File name="mock-pyth-oracle.clar" />
    </Folder>

    <File name="Clarinet.toml" />
  </Folder>
</Files>

## Pasos de implementación

<Steps>
  <Step>
    ### Escribir el contrato inteligente

    Primero, implemente el contrato de Clarity que lee los datos de precios de Pyth:

    ```clarity contracts/benjamin-club.clar
    ;; Benjamin Club - $100 NFT minting contract
    (define-constant CONTRACT-OWNER tx-sender)
    (define-constant BENJAMIN-COST u100) ;; $100 USD
    (define-constant ERR-INSUFFICIENT-FUNDS (err u100))
    (define-constant ERR-PRICE-UPDATE-FAILED (err u101))
    (define-constant ERR-STALE-PRICE (err u102))

    ;; Pyth oracle contracts
    (define-constant PYTH-ORACLE 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-oracle-v3)
    (define-constant PYTH-STORAGE 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3)
    (define-constant PYTH-DECODER 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-pnau-decoder-v2)
    (define-constant WORMHOLE-CORE 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.wormhole-core-v3)

    ;; BTC price feed ID
    (define-constant BTC-USD-FEED-ID 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43)

    ;; NFT definition
    (define-non-fungible-token benjamin-nft uint)
    (define-data-var last-token-id uint u0)

    (define-public (mint-for-hundred-dollars (price-feed-bytes (buff 8192)))
      (let (
        ;; Update price feed with fresh VAA data
        (update-result (try! (contract-call? PYTH-ORACLE
          verify-and-update-price-feeds price-feed-bytes {
            pyth-storage-contract: PYTH-STORAGE,
            pyth-decoder-contract: PYTH-DECODER,
            wormhole-core-contract: WORMHOLE-CORE
          })))

        ;; Get the updated BTC price
        (price-data (try! (contract-call? PYTH-ORACLE
          get-price BTC-USD-FEED-ID PYTH-STORAGE)))

        ;; Process the price data
        (btc-price (process-price-data price-data))

        ;; Calculate required sBTC amount for $100
        (required-sbtc (calculate-sbtc-amount btc-price))

        ;; Get user's sBTC balance
        (user-balance (unwrap!
          (contract-call? .sbtc-token get-balance tx-sender)
          ERR-INSUFFICIENT-FUNDS))
      )
        ;; Verify price is fresh (less than 5 minutes old)
        (try! (verify-price-freshness price-data))

        ;; Verify user has enough sBTC
        (asserts! (>= user-balance required-sbtc) ERR-INSUFFICIENT-FUNDS)

        ;; Transfer sBTC from user
        (try! (contract-call? .sbtc-token transfer
          required-sbtc tx-sender (as-contract tx-sender) none))

        ;; Mint the NFT
        (let ((token-id (+ (var-get last-token-id) u1)))
          (try! (nft-mint? benjamin-nft token-id tx-sender))
          (var-set last-token-id token-id)
          (ok { token-id: token-id, price-paid: required-sbtc }))
      )
    )

    (define-private (process-price-data (price-data {
      price-identifier: (buff 32),
      price: int,
      conf: uint,
      expo: int,
      ema-price: int,
      ema-conf: uint,
      publish-time: uint,
      prev-publish-time: uint
    }))
      (let (
        ;; Convert fixed-point to regular number
        ;; For expo = -8, divide by 10^8
        (denominator (pow u10 (to-uint (* (get expo price-data) -1))))
        (price-uint (to-uint (get price price-data)))
      )
        (/ price-uint denominator)
      )
    )

    (define-private (calculate-sbtc-amount (btc-price-usd uint))
      ;; $100 in sats = (100 * 10^8) / btc-price-usd
      (/ (* BENJAMIN-COST u100000000) btc-price-usd)
    )

    (define-private (verify-price-freshness (price-data (tuple)))
      (let (
        (current-time (unwrap-panic (get-block-info? time block-height)))
        (publish-time (get publish-time price-data))
        (max-age u300) ;; 5 minutes
      )
        (if (<= (- current-time publish-time) max-age)
          (ok true)
          ERR-STALE-PRICE)
      )
    )
    ```

    Para una explicación detallada de los componentes del contrato, consulte nuestra [Guía de integración de Clarity](/resources/clarity/external-data).
  </Step>

  <Step>
    ### Construir la integración del frontend

    Crear un servicio para obtener datos de precios de Pyth:

    ```typescript frontend/pyth-service.ts
    import { PriceServiceConnection } from '@pythnetwork/price-service-client';
    import { Buffer } from 'buffer';

    const PRICE_FEEDS = {
      BTC_USD: '0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43'
    };

    export async function fetchBTCPriceVAA(): Promise<string> {
      const pythClient = new PriceServiceConnection(
        'https://hermes.pyth.network',
        { priceFeedRequestConfig: { binary: true } }
      );

      const vaas = await pythClient.getLatestVaas([PRICE_FEEDS.BTC_USD]);
      const messageBuffer = Buffer.from(vaas[0], 'base64');

      return `0x${messageBuffer.toString('hex')}`;
    }
    ```

    Luego cree un componente de React para acuñar:

    ```typescript frontend/MintButton.tsx
    import { request } from '@stacks/connect';
    import { Cl, Pc } from '@stacks/transactions';
    import { fetchBTCPriceVAA } from './pyth-service';
    import { useState } from 'react';

    export function MintBenjaminNFT() {
      const [loading, setLoading] = useState(false);

      const handleMint = async () => {
        setLoading(true);
        try {
          // Fetch fresh price data
          const priceVAA = await fetchBTCPriceVAA();

          // Create post-conditions for safety
          const postConditions = [
            // Oracle fee (1 uSTX max)
            Pc.principal('SP1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRCBGD7R').willSendLte(1).ustx()
          ];

          // Call contract using request
          const response = await request('stx_callContract', {
            contract: 'SP1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRCBGD7R.benjamin-club',
            functionName: 'mint-for-hundred-dollars',
            functionArgs: [Cl.bufferFromHex(priceVAA.slice(2))],
            postConditions,
            postConditionMode: 'deny',
            network: 'mainnet'
          });

          alert(`NFT minted! Transaction ID: ${response.txid}`);
        } catch (error) {
          console.error('Minting failed:', error);
          alert('Failed to mint NFT');
        } finally {
          setLoading(false);
        }
      };

      return (
        <button
          onClick={handleMint}
          disabled={loading}
          className="px-6 py-3 bg-blue-600 text-white rounded-lg"
        >
          {loading ? 'Fetching price...' : 'Mint Benjamin NFT ($100)'}
        </button>
      );
    }
    ```

    Para obtener detalles completos sobre la integración del frontend, consulte nuestra [Guía de integración de Stacks.js](/reference/stacks.js/pyth-oracle-integration).
  </Step>

  <Step>
    ### Prueba tu implementación

    Escriba pruebas exhaustivas utilizando Clarinet:

    ```typescript tests/benjamin-club.test.ts
    import { describe, expect, it } from "vitest";
    import { Cl } from '@stacks/transactions';

    describe("Benjamin Club Tests", () => {
      it("should calculate correct sBTC amount", () => {
        // Set mock BTC price to $100,000
        simnet.callPublicFn(
          "mock-pyth-oracle",
          "set-mock-price",
          [
            Cl.bufferFromHex(BTC_FEED_ID),
            Cl.int(10000000000000), // $100,000 with 8 decimals
            Cl.int(-8)
          ],
          deployer
        );

        // Test price calculation
        const response = simnet.callReadOnlyFn(
          "benjamin-club",
          "get-required-sbtc-amount",
          [],
          wallet1
        );

        // $100 at $100k/BTC = 0.001 BTC = 100,000 sats
        expect(response.result).toBeOk(Cl.uint(100000));
      });
    });
    ```

    Para estrategias avanzadas de pruebas, incluyendo simulación de mainnet, consulte nuestra [Guía de pruebas de Clarinet](/tools/clarinet/pyth-oracle-integration).
  </Step>
</Steps>

## Mejores prácticas

### Frescura del precio

Siempre verifique que los datos de precios sean lo suficientemente recientes para su caso de uso:

```clarity
(define-constant MAX-PRICE-AGE u300) ;; 5 minutes

(define-private (verify-price-freshness (price-data (tuple)))
  (let ((age (- block-height (get publish-time price-data))))
    (asserts! (<= age MAX-PRICE-AGE) ERR-STALE-PRICE)
    (ok true)))
```

### Manejo de errores

Implementar un manejo integral de errores para fallos del oráculo:

```typescript
try {
  const vaa = await fetchBTCPriceVAA();
  // Process VAA...
} catch (error) {
  if (error.message.includes('Network')) {
    // Retry with exponential backoff
    await retryWithBackoff(() => fetchBTCPriceVAA());
  } else {
    // Handle other errors
    throw error;
  }
}
```

### Optimización de gas

Agrupe múltiples actualizaciones de precios cuando sea posible:

```clarity
(define-public (update-multiple-prices
  (btc-vaa (buff 8192))
  (eth-vaa (buff 8192))
  (stx-vaa (buff 8192)))
  (let ((all-vaas (concat btc-vaa (concat eth-vaa stx-vaa))))
    (contract-call? PYTH-ORACLE verify-and-update-price-feeds all-vaas params)))
```

## Solución de problemas

### Problemas comunes

<Accordion type="single" collapsible>
  <AccordionItem value="errores de vaa">
    <AccordionTrigger>La verificación de VAA falla</AccordionTrigger>

    <AccordionContent>
      Asegúrate de obtener datos VAA con `binary: true` opción y convirtiendo de base64 a hexadecimal correctamente. El VAA debe ser reciente (típicamente dentro de 5 minutos).
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="conversión de precio">
    <AccordionTrigger>Los cálculos de precios son incorrectos</AccordionTrigger>

    <AccordionContent>
      Verifica que estés manejando el exponente correctamente. Pyth utiliza una representación de punto fijo donde el precio real = precio\_bruto \* 10^exponente. Para exponentes negativos, divide por 10^(-exponente).
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="problemas-de-gas">
    <AccordionTrigger>Se agota el gas de la transacción</AccordionTrigger>

    <AccordionContent>
      Las actualizaciones del oráculo pueden consumir mucho gas. Asegúrese de que sus límites de gas tengan en cuenta tanto la actualización del oráculo como la lógica de su contrato. Considere almacenar en caché los precios cuando múltiples operaciones necesiten el mismo precio.
    </AccordionContent>
  </AccordionItem>
</Accordion>

## Consideraciones de seguridad

1. **Manipulación de precios**: Utiliza siempre intervalos de confianza e implementa comprobaciones de cordura
2. **Adelantamiento**: Considere utilizar esquemas de compromiso-revelación para operaciones sensibles al precio
3. **Tarifas del oráculo**: Establecer condiciones posteriores apropiadas para limitar la exposición a tarifas
4. **Obsolescencia**: Rechazar precios más antiguos que tu umbral de seguridad

## Referencia rápida

### Direcciones de contratos

| Red | Contrato | Dirección |
|---------|----------|---------|
| Mainnet | pyth-oracle-v3 | `SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-oracle-v3` |
| Mainnet | pyth-storage-v3 | `SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3` |
| Red de pruebas | pyth-oracle-v3 | `ST3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-oracle-v3` |

### IDs de fuentes de precios

| Activo | ID del Feed |
|-------|---------|
| BTC/USD | `0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43` |
| STX/USD | `0xec7a775f46379b5e943c3526b1c8d54cd49749176b0b98e02dde68d1bd335c17` |
| ETH/USD | `0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace` |
| USDC/USD | `0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a` |

## Recursos adicionales

* [Documentación de Pyth Network](https://docs.pyth.network)
* [Integración de Pyth en Trust Machines](https://github.com/Trust-Machines/stacks-pyth-bridge)
* [Especificación VAA de Wormhole](https://wormhole.com/docs/protocol/infrastructure/vaas/)

## Próximos pasos

:::next-steps
* [Inmersión profunda en Clarity](/resources/clarity/external-data): Patrones avanzados de oráculos y optimizaciones
* [Inmersión profunda en el frontend](/reference/stacks.js/pyth-oracle-integration): Construyendo interfaces de usuario de oráculos listas para producción
:::
