---
title: Formateador de claridad
sidebarTitle: Formateador de claridad
description: El formateador de Clarity es una herramienta diseñada para formatear automáticamente el código de tu contrato inteligente en Clarity según reglas de estilo estandarizadas. Usar un formato consistente mejora la legibilidad y mantenibilidad del código, facilitando a los desarrolladores entender, colaborar y aprender de proyectos existentes en Clarity.
---
## Filosofía de formato

El formateador aplica un estándar predefinido diseñado para hacer que el código de Clarity sea más legible:

* **Longitud de línea** - Las líneas se ajustan a 80 caracteres por defecto
* **Sangría** - Usa 2 espacios para consistencia
* **Estructura** - Impone patrones consistentes para funciones, enlaces let y flujo de control

Estos valores predeterminados son configurables para adaptarse a tus preferencias.

### Puntos de integración

El formateador está disponible en dos herramientas de desarrollo principales:

1. **Extensión Clarity para VS Code** - Formatear directamente dentro de tu editor
2. **Clarinet CLI** - Formatear a través de la línea de comandos, incluyendo proyectos completos

## Tabla de comparación

| Aspecto | Formato Manual | Formateador de Clarity |
|--------|------------------|-------------------|
| Consistencia | Varía según el desarrollador | Uniforme en toda la base de código |
| Velocidad | Consume tiempo | Instantáneo |
| Propenso a errores | Sí | No |
| Coordinación del equipo | Requiere guía de estilo | Aplicación automática |

## Mejores prácticas

* **Formatear al guardar** - Habilitar el formato automático en VS Code
* **Ganchos pre-commit** - Asegúrate de que todo el código esté formateado antes de los commits
* **Adopción del equipo** - Utiliza configuraciones consistentes en todo tu equipo

## Lecturas adicionales

### Reglas de formato en detalle

El formateador maneja muchas construcciones de Clarity con reglas específicas:

<Accordion type="single" collapsible className="w-full">
  <AccordionItem value="definiciones-de-funciones">
    <AccordionTrigger>Definiciones de funciones</AccordionTrigger>

    <AccordionContent>
      Las funciones siempre abarcan múltiples líneas con sangría consistente:

      ```clarity
      (define-public (my-func
          (amount uint)
          (sender principal)
        )
        (ok true)
      )
      ```

      Los argumentos individuales pueden permanecer en la primera línea:

      ```clarity
      (define-read-only (get-balance (who principal))
        (ok u0)
      )
      ```
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="expresiones-let">
    <AccordionTrigger>Expresiones let</AccordionTrigger>

    <AccordionContent>
      Los enlaces se colocan en líneas separadas con sangría consistente:

      ```clarity
      (let (
        (a u1)
        (b u2)
      )
        (body-expression)
      )
      ```
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="flujo-de-control">
    <AccordionTrigger>Control de flujo (if, match)</AccordionTrigger>

    <AccordionContent>
      Cada rama obtiene su propia línea:

      ```clarity
      (if condition
        (then-expression)
        (else-expression)
      )

      (match optional-value
        value (handle-some value)
        (handle-none)
      )
      ```
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="tuplas-mapas">
    <AccordionTrigger>Tuplas y mapas</AccordionTrigger>

    <AccordionContent>
      Convierte automáticamente a sintaxis endulzada con formato adecuado:

      ```clarity
      ;; Input: (tuple (n1 u1) (n2 u2))
      ;; Output:
      {
        n1: u1,
        n2: u2,
      }
      ```
    </AccordionContent>
  </AccordionItem>
</Accordion>

### Ejemplos de uso

#### Integración con VS Code

```json
// settings.json
"[clarity]": {
  "editor.formatOnSave": true,
},
```

#### Uso de la CLI

```terminal
$ clarinet format --in-place
```

Formato con configuraciones personalizadas:

```terminal
$ clarinet format -i 4 -l 120 --in-place
```

Verificar el formato en los pipelines de CI/CD:

```terminal
$ clarinet format --check
```

El `--check` flag valida que todos los archivos de Clarity estén correctamente formateados sin modificarlos. Esto es perfecto para flujos de trabajo de integración continua donde se desea garantizar la consistencia del estilo de código.

### Ignorando bloques de código

Evitar el formato de bloques de código específicos:

```clarity
;; @format-ignore
(define-constant something (list
  1     2  3  ;; Preserves custom spacing
  4 5 ))
```
