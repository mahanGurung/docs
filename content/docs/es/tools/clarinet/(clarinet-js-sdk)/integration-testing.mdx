---
title: Escribiendo pruebas de integración
sidebarTitle: Pruebas de integración
description: Las pruebas de integración son un paso crucial en el desarrollo de contratos inteligentes que implica probar cómo funcionan juntos los diferentes componentes de su sistema. El SDK de Clarinet JS proporciona herramientas poderosas para escribir y ejecutar pruebas de integración, permitiéndole simular escenarios complejos e interacciones entre múltiples contratos.
---
import { ArrowRight, Check } from 'lucide-react';

## Lo que aprenderás

:::objectives
* Configurar pruebas de integración para flujos de trabajo de múltiples pasos
* Probando interacciones y dependencias de contratos
* Simular escenarios del mundo real
* Verificar cambios de estado en todo el sistema
:::

## Configura tu proyecto

Crea un nuevo proyecto de Clarinet e instala las dependencias:

```terminal
$ clarinet new stx-defi
$ cd stx-defi
$ npm install
```

## Crear el contrato mejorado

Utilizaremos un contrato DeFi mejorado que admite tanto depósitos como préstamos. Cree el contrato:

```terminal
$ clarinet contract new defi
```

Reemplazar `contracts/defi.clar` con esta versión mejorada:

```clarity contracts/defi.clar
;; Error constants
(define-constant err-overborrow (err u300))

;; Interest rate (10%)
(define-data-var loan-interest-rate uint u10)

;; Total deposits in the contract
(define-data-var total-deposits uint u0)

;; User deposits
(define-map deposits { owner: principal } { amount: uint })

;; User loans
(define-map loans principal { amount: uint, last-interaction-block: uint })

;; Deposit STX into the contract
(define-public (deposit (amount uint))
  (let
    (
      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
    )
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
    (var-set total-deposits (+ (var-get total-deposits) amount))
    (ok true)
  )
)

;; Borrow STX based on deposits (up to 50% of deposit)
(define-public (borrow (amount uint))
  (let
    (
      (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
      (allowed-borrow (/ user-deposit u2))
      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 }
                            (map-get? loans tx-sender)))
      (accrued-interest (calculate-accrued-interest
                         (get amount current-loan-details)
                         (get last-interaction-block current-loan-details)))
      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
      (new-loan (+ amount))
    )
    (asserts! (<= new-loan allowed-borrow) err-overborrow)
    (try! (as-contract (stx-transfer? amount tx-sender tx-sender)))
    (map-set loans tx-sender { amount: new-loan, last-interaction-block: block-height })
    (ok true)
  )
)

;; Get user's balance
(define-read-only (get-balance-by-sender)
  (ok (map-get? deposits { owner: tx-sender }))
)

;; Get amount owed including interest
(define-read-only (get-amount-owed)
  (let
    (
      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 }
                            (map-get? loans tx-sender)))
      (accrued-interest (calculate-accrued-interest
                         (get amount current-loan-details)
                         (get last-interaction-block current-loan-details)))
      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))
    )
    (ok total-due)
  )
)

;; Calculate interest
(define-private (calculate-accrued-interest (principal uint) (start-block uint))
  (let
    (
      (elapsed-blocks (- block-height start-block))
      (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))
    )
    (asserts! (not (is-eq start-block u0)) (ok u0))
    (ok interest)
  )
)
```

Correr `clarinet check` para asegurar que su contrato sea válido:

```terminal
$ clarinet check
[32m✔ 1 contract checked[0m
```

## Escribir pruebas de integración

Crea una prueba que simule un flujo de trabajo completo del usuario - depositar y luego pedir prestado:

```typescript tests/defi.test.ts
import { describe, it, expect } from 'vitest';
import { Cl } from '@stacks/transactions';

const accounts = simnet.getAccounts();
const wallet1 = accounts.get('wallet_1')!;

describe('stx-defi integration', () => {
  it('allows deposit and borrow workflow', () => {
    // Step 1: User deposits STX
    const depositResult = simnet.callPublicFn(
      'defi',
      'deposit',
      [Cl.uint(1000)],
      wallet1
    );
    expect(depositResult.result).toBeOk(Cl.bool(true));

    // Verify deposit was recorded
    const totalDeposits = simnet.getDataVar('defi', 'total-deposits');
    expect(totalDeposits).toBeUint(1000);

    // Step 2: User borrows against deposit
    const borrowResult = simnet.callPublicFn(
      'defi',
      'borrow',
      [Cl.uint(400)], // Borrowing 40% of deposit
      wallet1
    );
    expect(borrowResult.result).toBeOk(Cl.bool(true));

    // Step 3: Check amount owed
    const { result } = simnet.callReadOnlyFn(
      'defi',
      'get-amount-owed',
      [],
      wallet1
    );
    expect(result).toBeOk(Cl.uint(400)); // No interest yet at same block
  });

  it('prevents over-borrowing', () => {
    // Setup: deposit first
    simnet.callPublicFn('defi', 'deposit', [Cl.uint(1000)], wallet1);

    // Attempt to borrow more than allowed (>50%)
    const borrowResult = simnet.callPublicFn(
      'defi',
      'borrow',
      [Cl.uint(600)],
      wallet1
    );

    // Should fail with err-overborrow
    expect(borrowResult.result).toBeErr(Cl.uint(300));
  });
});
```

En esta prueba de integración, estamos simulando un escenario donde un usuario deposita STX en el contrato DeFi y luego pide un préstamo contra ese depósito. Analicemos los aspectos clave:

* **`callPublicFn`** - Simula la llamada a funciones públicas tal como en la cadena de bloques real
* **`getDataVar`** - Recupera el valor de las variables de datos del contrato
* **`callReadOnlyFn`** - Llama a funciones de solo lectura sin modificar el estado
* **Comparadores personalizados** - `toBeOk()` y `toBeErr()` validar tipos de respuesta de Clarity

## Pruébalo

Ejecute sus pruebas de integración:

```terminal
$ npm run test
```

## Problemas comunes

| Problema | Solución |
|-------|----------|
| Contaminación del estado entre pruebas | Cada prueba se ejecuta de forma aislada - el estado no se transfiere |
| Problemas de sincronización | Usar `simnet.mineEmptyBlocks()` para avanzar la altura del bloque |
| Afirmaciones complejas | Desglosar en pruebas más pequeñas y enfocadas |

## Próximos pasos

:::next-steps
* [Referencia del SDK](/tools/clarinet/sdk-reference): Aprende más sobre el SDK de Clarinet JS.
* [Integración de Stacks.js](/tools/clarinet/stacks-js-integration): Aprende cómo integrar Stacks.js con tu proyecto de Clarinet.
:::
