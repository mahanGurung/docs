---
title: Escribiendo pruebas unitarias
sidebarTitle: Pruebas unitarias
description: El testing unitario es el proceso de probar componentes o funciones individuales de contratos inteligentes para asegurar que funcionen como se espera. El SDK de Clarinet JS proporciona un marco de pruebas que te permite escribir estas pruebas utilizando el framework de testing Vitest, ayudándote a detectar errores y fallos temprano en el proceso de desarrollo.
---
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@/components/ui/accordion';

import { ArrowRight, Check } from 'lucide-react';

## Lo que aprenderás

:::objectives
* Configurar un proyecto de Clarinet para pruebas unitarias
* Escribir pruebas unitarias para funciones públicas y de solo lectura
* Probar condiciones de error y casos límite
* Ejecutar pruebas y generar informes de cobertura
:::

## Configura tu proyecto

Comience creando un nuevo proyecto con la CLI de Clarinet. Este comando crea una estructura de proyecto con los archivos y carpetas necesarios, incluyendo el SDK JS de Clarinet ya configurado para pruebas:

```terminal
$ clarinet new stx-defi
$ cd stx-defi
```

Después de cambiar al directorio de su proyecto, instale las dependencias del paquete:

```terminal
$ npm install
```

## Crear el contrato

Generar un nuevo archivo de contrato utilizando la CLI de Clarinet:

```terminal
$ clarinet contract new defi
```

Reemplace el contenido de `contracts/defi.clar` con este contrato DeFi:

```clarity contracts/defi.clar
;; Holds the total amount of deposits in the contract
(define-data-var total-deposits uint u0)

;; Maps a user's principal address to their deposited amount
(define-map deposits { owner: principal } { amount: uint })

;; Public function for users to deposit STX into the contract
(define-public (deposit (amount uint))
  (let
    (
      ;; Fetch the current balance or default to 0 if none exists
      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
    )
    ;; Transfer the STX from sender to contract
    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))
    ;; Update the user's deposit amount in the map
    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
    ;; Update the total deposits variable
    (var-set total-deposits (+ (var-get total-deposits) amount))
    ;; Return success
    (ok true)
  )
)

;; Read-only function to get the balance by tx-sender
(define-read-only (get-balance-by-sender)
  (ok (map-get? deposits { owner: tx-sender }))
)
```

Correr `clarinet check` para garantizar que su contrato sea válido:

```terminal
$ clarinet check
[32m✔ 1 contract checked[0m
```

## Escriba su prueba unitaria

Las pruebas clave que queremos cubrir son que el depósito sea exitoso y que el saldo del usuario, así como los depósitos totales del contrato, se actualicen correctamente.

Reemplace el contenido de `tests/defi.test.ts`:

```typescript tests/defi.test.ts
import { describe, it, expect } from 'vitest';
import { Cl } from '@stacks/transactions';

const accounts = simnet.getAccounts();
const wallet1 = accounts.get('wallet_1')!;

describe('stx-defi', () => {
  it('allows users to deposit STX', () => {
    // Define the amount to deposit
    const amount = 1000;

    // Call the deposit function
    const deposit = simnet.callPublicFn('defi', 'deposit', [Cl.uint(amount)], wallet1);

    // Assert the deposit was successful
    expect(deposit.result).toBeOk(Cl.bool(true));

    // Verify the contract's total deposits
    const totalDeposits = simnet.getDataVar('defi', 'total-deposits');
    expect(totalDeposits).toBeUint(amount);

    // Check the user's balance
    const balance = simnet.callReadOnlyFn('defi', 'get-balance-by-sender', [], wallet1);
    expect(balance.result).toBeOk(
      Cl.some(
        Cl.tuple({
          amount: Cl.uint(amount),
        })
      )
    );
  });
});
```

Analicemos las partes clave de esta prueba:

* **`simnet.callPublicFn`** - Llama a una función pública en tu contrato
* **`expect().toBeOk()`** - Comparador personalizado que verifica la claridad `ok` respuesta
* **`simnet.getDataVar`** - Recupera el valor de una variable de datos
* **`Cl` ayudantes** - Crear valores de Clarity en JavaScript

## Pruébalo

Ejecuta tu prueba para verla en acción:

```terminal
$ npm run test
 PASS  tests/defi.test.ts
  stx-defi
    allows users to deposit STX (5 ms)

Test Files  1 passed (1)
     Tests  1 passed (1)
```

## Problemas comunes

| Problema | Solución |
|----------|----------|
| `toBeOk is not a function` | Asegúrese de estar utilizando los comparadores personalizados del SDK |
| `Contract not found` | Correr `clarinet check` para validar su contrato |
| `Type errors` | Utilice el `Cl` ayudantes para crear valores de Clarity adecuados |

<Accordion type="single" collapsible>
  <AccordionItem value="cobertura">
    <AccordionTrigger>Generar informes de cobertura</AccordionTrigger>

    <AccordionContent>
      <div className="pb-4 pt-2">
        Ejecutar pruebas con cobertura para identificar código no probado:

        ```terminal
        $ npm run test:report
        ```

        Esto genera:

        * `lcov.info` - Datos de cobertura de código
        * `costs-reports.json` - Análisis de costo de gas

        Para ver el informe de cobertura:

        ```terminal
        $ brew install lcov
        $ genhtml lcov.info --branch-coverage -o coverage
        $ open coverage/index.html
        ```
      </div>
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="avanzado">
    <AccordionTrigger>Patrones de pruebas avanzados</AccordionTrigger>

    <AccordionContent>
      <div className="pb-4 pt-2">
        Probar condiciones de error:

        ```typescript
        it('fails when depositing zero', () => {
          const deposit = simnet.callPublicFn('defi', 'deposit', [Cl.uint(0)], wallet1);
          expect(deposit.result).toBeErr(Cl.uint(100)); // err-invalid-amount
        });
        ```

        Prueba con múltiples cuentas:

        ```typescript
        const wallet2 = accounts.get('wallet_2')!;

        it('tracks deposits from multiple users', () => {
          simnet.callPublicFn('defi', 'deposit', [Cl.uint(1000)], wallet1);
          simnet.callPublicFn('defi', 'deposit', [Cl.uint(2000)], wallet2);

          const total = simnet.getDataVar('defi', 'total-deposits');
          expect(total).toBeUint(3000);
        });
        ```
      </div>
    </AccordionContent>
  </AccordionItem>
</Accordion>

## Próximos pasos

:::next-steps
* [Pruebas de integración](/tools/clarinet/integration-testing): Aprende cómo probar tu contrato con pruebas de integración.
* [Simulación de ejecución de la red principal](/tools/clarinet/mainnet-execution-simulation): Aprende cómo probar tu contrato con el estado de la red principal.
:::
