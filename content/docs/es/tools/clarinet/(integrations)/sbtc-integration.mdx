---
title: Integración de sBTC con Clarinet
sidebarTitle: Integración de sBTC
description: En esta guía, aprenderás cómo interactuar con el contrato sBTC de la red principal en tu proyecto de Clarinet.
---
## Lo que aprenderás

:::objectives
* Agregar contratos inteligentes de sBTC a su proyecto de Clarinet
* Probar contratos con financiación automática de sBTC en devnet
* Trabajar con sBTC como un token fungible SIP-010
* Desplegar contratos de sBTC en testnet y mainnet
:::

## Requisitos previos

:::prerequisites
* Se requiere Clarinet 2.15.0 o posterior para la integración automática de sBTC.
:::

## Inicio rápido

<Steps>
  <Step>
    ### Añade sBTC a tu proyecto

    Agregue los contratos inteligentes de sBTC a los requisitos de su proyecto Clarinet:

    ```terminal
    $ clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit
    ```

    Este comando agrega tres contratos esenciales:

    * **`sbtc-token`** - El contrato de token SIP-010 principal
    * **`sbtc-registry`** - Registro para gestionar la configuración de sBTC
    * **`sbtc-deposit`** - Maneja operaciones de depósito y retiro

    Cuando Clarinet detecta estos contratos, automáticamente financia sus billeteras de prueba con sBTC para realizar pruebas.
  </Step>

  <Step>
    ### Crear un contrato habilitado para sBTC

    Construye un mercado simple de NFT que acepte pagos en sBTC:

    ```clarity contracts/nft-marketplace.clar
    ;; Define NFT
    (define-non-fungible-token marketplace-nft uint)

    ;; Price in sats (smallest sBTC unit)
    (define-data-var mint-price uint u100)
    (define-data-var next-id uint u0)

    ;; Mint NFT with sBTC payment
    (define-public (mint-with-sbtc)
      (begin
        ;; Transfer sBTC from buyer to contract
        (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
          (var-get mint-price)
          tx-sender
          (as-contract tx-sender)
          none
        ))

        ;; Mint the NFT
        (try! (nft-mint? marketplace-nft (var-get next-id) tx-sender))

        ;; Increment ID for next mint
        (ok (var-set next-id (+ (var-get next-id) u1)))
      )
    )

    ;; Check sBTC balance
    (define-read-only (get-sbtc-balance (owner principal))
      (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance owner)
    )
    ```
  </Step>

  <Step>
    ### Probar en la consola de Clarinet

    Clarinet financia automáticamente las billeteras de prueba con sBTC. Prueba tu contrato:

    ```terminal
    $ clarinet console
    ```

    Verifique los saldos de la billetera y acuñe un NFT:

    ```clarity
    ;; Check deployer's sBTC balance (auto-funded)
    (contract-call? .nft-marketplace get-sbtc-balance tx-sender)

    ;; Mint NFT with wallet_1 (also auto-funded)
    (contract-call? .nft-marketplace mint-with-sbtc)

    ;; Verify NFT ownership
    (nft-get-owner? .nft-marketplace marketplace-nft u0)
    ```
  </Step>

  <Step>
    ### Escribir pruebas unitarias

    Prueba la funcionalidad de sBTC en tus pruebas de TypeScript:

    ```ts tests/nft-marketplace.test.ts
    import { describe, expect, it } from "vitest";
    import { Cl } from "@stacks/transactions";

    describe("NFT Marketplace", () => {
      it("mints NFT with sBTC payment", () => {
        const mintPrice = 100;

        // Get initial sBTC balance
        const initialBalance = simnet.callReadOnlyFn(
          "nft-marketplace",
          "get-sbtc-balance",
          [Cl.standardPrincipal(accounts.get("wallet_1")!.address)],
          accounts.get("wallet_1")!.address
        );

        // Mint NFT
        const mintResult = simnet.callPublicFn(
          "nft-marketplace",
          "mint-with-sbtc",
          [],
          accounts.get("wallet_1")!.address
        );

        expect(mintResult.result).toBeOk();

        // Verify sBTC was transferred
        const finalBalance = simnet.callReadOnlyFn(
          "nft-marketplace",
          "get-sbtc-balance",
          [Cl.standardPrincipal(accounts.get("wallet_1")!.address)],
          accounts.get("wallet_1")!.address
        );

        expect(Number(Cl.parse(finalBalance.result))).toBeLessThan(
          Number(Cl.parse(initialBalance.result))
        );
      });
    });
    ```
  </Step>

  <Step>
    ### Desplegar en testnet

    En la red de pruebas, Clarinet automáticamente se reasigna a los contratos oficiales de sBTC de Hiro:

    ```terminal
    $ clarinet deployments generate --testnet
    ```

    Su plan de implementación muestra las direcciones reasignadas:

    ```yaml deployments/default.testnet-plan.yaml
    ---
    id: 0
    name: Testnet deployment
    network: testnet
    stacks-node: "https://api.testnet.hiro.so"
    bitcoin-node: "http://blockstream.info"
    plan:
      batches:
        - id: 0
          transactions:
            - requirement-publish:
                contract-id: ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token
                remap-sender: SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4
                remap-principals:
                  SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4: ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT
                cost: 50000
                path: "./.cache/requirements/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token.clar"
    ```

    Desplegar en testnet:

    ```terminal
    $ clarinet deployments apply -p deployments/default.testnet-plan.yaml
    ```
  </Step>
</Steps>

## Patrones comunes

## Trabajando con direcciones sBTC

Clarinet maneja el mapeo de direcciones de contratos sBTC a través de las redes:

| Red | Dirección del Contrato sBTC |
|---------|---------------------|
| Simnet/Devnet | `SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token` |
| Red de pruebas | `ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token` |
| Mainnet | La dirección del contrato permanece sin cambios |

Su código de contrato siempre hace referencia a la dirección de simnet. Clarinet automáticamente reasigna durante el despliegue.

## Minting manual de sBTC en pruebas unitarias

Aunque Clarinet 2.15.0+ financia automáticamente las billeteras con sBTC en devnet, es posible que necesite acuñar manualmente sBTC en pruebas unitarias para escenarios específicos:

### Acuñando sBTC utilizando la dirección del implementador

El contrato de token sBTC permite que la dirección del implementador (multisig) acuñe tokens. Utiliza este enfoque en tus pruebas:

```typescript tests/manual-sbtc-mint.test.ts -c
import { describe, expect, it } from "vitest";
import { Cl } from "@stacks/transactions";

describe("Manual sBTC minting", () => {
  it("mints sBTC to custom addresses", () => {
    // The sBTC multisig address that can mint
    const sbtcDeployer = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4";
    const customWallet = "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM";

    // Mint 1000 sats to custom wallet
    const mintResult = simnet.callPublicFn(
      "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
      "mint",
      [
        Cl.uint(1000),              // amount in sats
        Cl.principal(customWallet)   // recipient
      ],
      sbtcDeployer                   // sender must be deployer
    );

    expect(mintResult.result).toBeOk(Cl.bool(true));

    // Verify balance
    const balance = simnet.callReadOnlyFn(
      "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
      "get-balance",
      [Cl.principal(customWallet)],
      customWallet
    );

    expect(balance.result).toBeOk(Cl.uint(1000));
  });
});
```

### Pruebas con simulación de ejecución en la red principal

Cuando se utiliza la simulación de ejecución en la red principal, se puede acuñar sBTC utilizando la multifirma real de la red principal:

```typescript -c
const mainnetMultisig = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4";
const mainnetWallet = "SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR";

// Mint sBTC to any mainnet address
simnet.callPublicFn(
  "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
  "mint",
  [Cl.uint(100000), Cl.principal(mainnetWallet)],
  mainnetMultisig
);
```

Este enfoque es útil para:

* Probando cantidades específicas de sBTC
* Simulando diferentes saldos de billetera
* Probando casos límite con cantidades de tokens precisas
* Pruebas de integración con contratos de mainnet
